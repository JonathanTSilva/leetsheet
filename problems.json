[
  {
    "title": "Two Sum",
    "link": "https://leetcode.com/problems/two-sum/",
    "keywords": [
      "#Array",
      "#HashTable",
      "#Dictionary",
      "#OnePass"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We iterate through the list of N elements exactly once. Each hash table lookup and insertion is an average O(1) operation."
      },
      "space": {
        "notation": "O(N)",
        "justification": "In the worst-case scenario, we might store all N elements in the hash table if no solution is found until the very end of the array."
      }
    },
    "whiteboard": "The optimal approach uses a hash map (dictionary in Python) for a single-pass solution. As we iterate through the array, we store each number and its index. For each element, we calculate its 'complement' (the other number needed to reach the target) and check if that complement already exists in our hash map. This provides an average O(1) lookup time, making it vastly superior to the brute-force method of using two nested loops, which has a time complexity of O(N^2).",
    "dry_run": "Example: `nums = [2, 7, 11, 15]`, `target = 9`\n1. Initialize `nums_hash = {}`.\n2. `i = 0`, `num = 2`. Complement is `7`. Is `7` in hash? No. Add `2` to hash: `{2: 0}`.\n3. `i = 1`, `num = 7`. Complement is `2`. Is `2` in hash? Yes. Return `[hash[2], i]`, which is `[0, 1]`.",
    "test_cases": "- Empty input array.\n- No solution exists in the array.\n- Array with negative numbers.\n- Array with duplicate numbers that form a solution (e.g., `nums=[3,3], target=6`).\n- Target is zero.",
    "ia_solution": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        # Dictionary to map numbers to their indices for quick lookup\n        numToIndex = {}\n        \n        # Iterate through the list of numbers\n        for i in range(len(nums)):\n            complement = target - nums[i]  # The number we need to find to reach the target\n            \n            # If the complement is already in the dictionary, we found a valid pair\n            if complement in numToIndex:\n                return [numToIndex[complement], i]\n            \n            # Store the current number with its index for future lookups\n            numToIndex[nums[i]] = i\n        \n        # If no solution is found (problem statement usually guarantees one)\n        return []\n",
    "manual_solution": "class Solution:\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        # The hash map stores numbers we've seen and their indices.\n        nums_hash = {}\n        # FORYOU!!: Interviewer might ask why a hash map (dictionary) is used here.\n        # Answer: It provides O(1) average time complexity for lookups, which is crucial for an overall O(N) solution. A simple array search would be O(N), making the total time O(N^2).\n\n        # Iterate through the list with both index and value.\n        for i, num in enumerate(nums):\n            # Calculate the number needed to reach the target.\n            complement = target - num\n\n            # Check if this required complement is already in our hash map.\n            if complement in nums_hash:\n                # If it is, we've found our pair.\n                return [nums_hash[complement], i]\n\n            # If the complement isn't found, add the current number and its index to the map.\n            # We do this *after* the check to handle cases where a number is used twice (e.g., nums=[3,3], target=6)\n            nums_hash[num] = i"
  },
  {
    "title": "Add Two Numbers",
    "link": "https://leetcode.com/problems/add-two-numbers/",
    "keywords": [
      "#LinkedList",
      "#Math",
      "#Iteration",
      "#Carry",
      "#DummyNode"
    ],
    "complexity": {
      "time": {
        "notation": "O(max(M, N))",
        "justification": "We iterate through the linked lists until both are fully traversed. The number of iterations is determined by the length of the longer list (M or N)."
      },
      "space": {
        "notation": "O(max(M, N))",
        "justification": "The new linked list created to store the result will have a length of at most max(M, N) + 1, where the +1 accounts for a potential final carry."
      }
    },
    "whiteboard": "The problem requires adding two numbers represented by linked lists in reverse order. The most direct approach is to iterate through both lists simultaneously, simulating elementary school addition. We use a `carry` variable to handle sums greater than 9. A `dummy` head node is used to simplify the construction of the result list, avoiding edge cases for the first node.",
    "dry_run": "Example: `l1 = 2->4->3`, `l2 = 5->6->4`\n1. Initialize `carry = 0`, `dummy` node.\n2. Iteration 1: `2 + 5 + 0 = 7`. `carry=0`, `val=7`. Result: `dummy->7`.\n3. Iteration 2: `4 + 6 + 0 = 10`. `carry=1`, `val=0`. Result: `dummy->7->0`.\n4. Iteration 3: `3 + 4 + 1 = 8`. `carry=0`, `val=8`. Result: `dummy->7->0->8`.\n5. Loop ends. Return `dummy.next`.",
    "test_cases": "- One list is longer than the other.\n- Lists of different lengths resulting in a final carry (e.g., `[9,9] + [1]`).\n- One or both lists are empty.\n- Lists containing zeros.",
    "ia_solution": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        # Dictionary to map numbers to their indices for quick lookup\n        numToIndex = {}\n        \n        # Iterate through the list of numbers\n        for i in range(len(nums)):\n            complement = target - nums[i]  # The number we need to find to reach the target\n            \n            # If the complement is already in the dictionary, we found a valid pair\n            if complement in numToIndex:\n                return [numToIndex[complement], i]\n            \n            # Store the current number with its index for future lookups\n            numToIndex[nums[i]] = i\n        \n        # If no solution is found (problem statement usually guarantees one)\n        return []\n",
    "manual_solution": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        # A dummy node helps simplify the code by providing a fake head.\n        dummy = ListNode()\n        cur = dummy\n\n        # This will hold the carry-over value (0 or 1).\n        carry = 0\n\n        # Loop until we have processed both lists and there's no carry left.\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            total = v1 + v2 + carry\n            carry, val = divmod(total, 10)\n            \n            cur.next = ListNode(val)\n            cur = cur.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
    "keywords": [
      "#String",
      "#SlidingWindow",
      "#HashTable",
      "#Dictionary"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "This is a single-pass sliding window approach. Each character in the string is visited at most twice, once by the right pointer (`i`) and once by the left pointer (`start`)."
      },
      "space": {
        "notation": "O(min(N, M))",
        "justification": "The space is determined by the hash map size, which stores at most M unique characters (where M is the size of the character set) or N characters if all are unique."
      }
    },
    "whiteboard": "This problem is a classic example of the 'Sliding Window' technique. We use two pointers, `start` and `i`, to define a 'window' of a non-repeating substring. A hash map is used to store the most recent index of each character encountered. When a repeating character is found within the current window, we shrink the window by moving the `start` pointer to the position right after the previous occurrence of that character. This ensures O(N) time complexity as each character is visited at most twice.",
    "dry_run": "Example: `s = \"abcabcbb\"`\n1. `start = 0`, `chars = {}`, `mx = 0`.\n2. `i=0, char='a'`. Valid. `mx=1`. `chars={'a':0}`.\n3. `i=1, char='b'`. Valid. `mx=2`. `chars={'a':0, 'b':1}`.\n4. `i=2, char='c'`. Valid. `mx=3`. `chars={'a':0, 'b':1, 'c':2}`.\n5. `i=3, char='a'`. Repeat! `chars['a']` is `0`. `start <= 0` is true. Move `start` to `0+1=1`. Update `chars={'a':3, ...}`.",
    "test_cases": "- Empty string.\n- String with all unique characters.\n- String with all same characters (e.g., 'bbbbb').\n- String with special characters or numbers.",
    "ia_solution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # `max_len` will store the maximum length found so far.\n        max_len = 0\n        # `start` is the starting index of our current non-repeating substring (the left side of the window).\n        start = 0\n        # `chars` is a dictionary to store the last seen index of each character.\n        chars = {}\n\n        # FORYOU!!: This is a classic 'Sliding Window' problem. Be ready to name the technique.\n        # Answer: The window is defined by the `start` and `i` pointers. It expands by moving `i` and shrinks by moving `start` when a duplicate character is found inside the window.\n\n        for i, char in enumerate(s):\n            # Check if we've seen this character before AND if its last occurrence is within our current window.\n            if char in chars and start <= chars[char]:\n                # If so, a repeat has occurred. Move the start of our window to the right of the previous occurrence.\n                start = chars[char] + 1\n            \n            # Calculate the current window's length and update the max if needed.\n            max_len = max(max_len, i - start + 1)\n            \n            # Update the last seen index for the current character.\n            chars[char] = i\n            \n        return max_len",
    "manual_solution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # `mx` will store the maximum length found so far.\n        mx = 0\n        # `start` is the starting index of our current non-repeating substring.\n        start = 0\n        # `chars` is a dictionary to store the last seen index of each character.\n        chars = {}\n\n        for i, char in enumerate(s):\n            # Check if we've seen this character before AND if its last occurrence is within our current window.\n            if char in chars and start <= chars[char]:\n                # If so, a repeat has occurred. Move the start of our window.\n                start = chars[char] + 1\n            else:\n                # If no repeat, calculate its length and update the max if needed.\n                mx = max(mx, i - start + 1)\n            \n            # Update the last seen index for the current character.\n            chars[char] = i\n            \n        return mx"
  },
  {
    "title": "Median of Two Sorted Arrays",
    "link": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
    "keywords": [
      "#Array",
      "#BinarySearch",
      "#DivideAndConquer",
      "#Hard"
    ],
    "complexity": {
      "time": {
        "notation": "O(log(min(N, M)))",
        "justification": "This complexity is for the optimal solution which performs a binary search. The search space is the smaller of the two arrays, and it is halved in each step."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The optimal solution operates in-place using a few variables to track partitions, requiring no additional space proportional to the input size."
      }
    },
    "whiteboard": "The optimal solution for this problem has a time complexity of O(log(min(N,M))) and uses binary search. The goal is to find a partition in both arrays such that all elements in the 'left part' are smaller than all elements in the 'right part'. By performing a binary search on the smaller array to find this ideal partition, we can determine the median from the boundary elements (max of the left part and min of the right part) without merging the arrays. This is much more efficient than the naive O(N+M) approach of merging and sorting.",
    "dry_run": "Conceptual Dry Run: Binary search on smaller array `A`. Pick a partition `midA`. Calculate corresponding partition `midB`. Check if `max(leftA) <= min(rightB)` and `max(leftB) <= min(rightA)`. If not, adjust the binary search range in `A` (move left or right) until the condition is met. Once found, calculate median based on the boundary elements and total element count (even/odd).",
    "test_cases": "- One array is empty.\n- Arrays with no overlap in values (e.g., `[1,2]`, `[3,4]`).\n- Arrays with significant overlap.\n- Arrays of greatly different lengths.\n- Arrays with even or odd total number of elements.",
    "ia_solution": "class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n        # FORYOU!!: This is the optimal O(log(min(N, M))) solution. It's a hard problem, so clearly explaining the binary search logic is key. The goal is to partition the combined virtual array into two equal halves.\n        A, B = nums1, nums2\n        total = len(A) + len(B)\n        half = total // 2\n\n        # Ensure A is the smaller array to optimize the binary search.\n        if len(B) < len(A):\n            A, B = B, A\n        \n        l, r = 0, len(A) - 1\n\n        while True:\n            # i is the midpoint partition for array A.\n            i = (l + r) // 2\n            # j is the corresponding partition for array B.\n            j = half - (i + 1) - 1\n\n            # Get the four boundary elements for the partitions.\n            Aleft = A[i] if i >= 0 else float('-inf')\n            Aright = A[i + 1] if (i + 1) < len(A) else float('inf')\n            Bleft = B[j] if j >= 0 else float('-inf')\n            Bright = B[j + 1] if (j + 1) < len(B) else float('inf')\n\n            # Check if we found the correct partition.\n            # This means the max of the left half is <= the min of the right half.\n            if Aleft <= Bright and Bleft <= Aright:\n                # If the total number of elements is odd, the median is the smaller of the two right-half minimums.\n                if total % 2:\n                    return min(Aright, Bright)\n                # If even, it's the average of the two left-half maximums.\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft > Bright:\n                # A's partition is too large, move the search to the left in A.\n                r = i - 1\n            else:\n                # A's partition is too small, move the search to the right in A.\n                l = i + 1",
    "manual_solution": "import math\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n        # This is the straightforward, \"brute-force\" approach.\n        # NOTE: Interviewers expect the O(log(min(N,M))) solution.\n        arr = sorted(nums1 + nums2)\n        n = len(arr)\n        \n        # Acknowledge this solution's inefficiency in an interview.\n\n        if n % 2 == 0:\n            # If even, the median is the average of the two middle elements.\n            mid_right = arr[n // 2]\n            mid_left = arr[n // 2 - 1]\n            return (mid_left + mid_right) / 2\n        else:\n            # If odd, the median is simply the middle element.\n            return float(arr[n // 2])"
  },
  {
    "title": "Longest Palindromic Substring",
    "link": "https://leetcode.com/problems/longest-palindromic-substring/",
    "keywords": [
      "#String",
      "#DynamicProgramming",
      "#ExpandAroundCenter"
    ],
    "complexity": {
      "time": {
        "notation": "O(N^2)",
        "justification": "The 'Expand Around Center' approach has 2N-1 potential centers. For each center, we may expand outwards up to N/2 times in the worst case."
      },
      "space": {
        "notation": "O(1)",
        "justification": "This approach uses a fixed number of variables to store indices, not counting the space for the result string itself, thus requiring constant extra space."
      }
    },
    "whiteboard": "The 'Expand Around Center' technique is an intuitive and efficient way to solve this. It has the same O(N^2) time complexity as the dynamic programming approach but uses O(1) space. The idea is that any palindrome has a center. We iterate through each character of the string, treating it as a potential center, and expand outwards. We must handle two cases for the center: a single character (for odd-length palindromes like 'racecar') and the space between two characters (for even-length palindromes like 'aabbaa').",
    "dry_run": "Example: `s = \"babad\"`\n1. `res = \"\"`.\n2. Loop `i=0`: `check(0,0)` -> 'b'. `res='b'`. `check(0,1)` -> ''.\n3. Loop `i=1`: `check(1,1)` -> 'bab'. `res='bab'`. `check(1,2)` -> ''.\n4. Loop `i=2`: `check(2,2)` -> 'aba'. `len('aba')` is not > `len('bab')`. `res` remains 'bab'.\n5. Continue for all `i`. Final result is 'bab'.",
    "test_cases": "- Empty string.\n- String that is already a palindrome.\n- String with no palindrome longer than 1 character.\n- String with multiple palindromes of the same max length.",
    "ia_solution": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        # This will store the longest palindrome found so far.\n        res = \"\"\n\n        # FORYOU!!: Explain why 'Expand Around Center' is often preferred over DP for this problem.\n        # Answer: While both have an O(N^2) time complexity, this approach has a much better space complexity of O(1), whereas the DP solution requires an O(N^2) table. This makes it more efficient in terms of memory.\n\n        for i in range(len(s)):\n            # Check for odd length palindromes (center is the character itself).\n            # Example: \"racecar\", center is 'e'\n            p1 = self.expand_around_center(s, i, i)\n            if len(p1) > len(res):\n                res = p1\n\n            # Check for even length palindromes (center is between two characters).\n            # Example: \"aabbaa\", center is between 'b' and 'b'\n            p2 = self.expand_around_center(s, i, i + 1)\n            if len(p2) > len(res):\n                res = p2\n        \n        return res\n\n    def expand_around_center(self, s, l, r):\n        # Helper function to perform the expansion.\n        # Expand as long as pointers are in bounds and characters match.\n        while 0 <= l and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        # Return the valid palindrome found. The slice is s[l+1:r] because l and r are the first characters that *don't* match.\n        return s[l + 1:r]",
    "manual_solution": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        # This will store the longest palindrome found so far.\n        res = \"\"\n\n        # Helper function to perform the expansion.\n        def check(l, r):\n            # Expand as long as pointers are in bounds and characters match.\n            while 0 <= l and r < len(s) and s[l] == s[r]:\n                l -= 1\n                r += 1\n            # Return the valid palindrome found.\n            return s[l + 1:r]\n\n        for i in range(len(s)):\n            # Check for odd length palindromes (center is the character itself).\n            odd_pal = check(i, i)\n            if len(odd_pal) > len(res):\n                res = odd_pal\n\n            # Check for even length palindromes (center is between two characters).\n            even_pal = check(i, i + 1)\n            if len(even_pal) > len(res):\n                res = even_pal\n        \n        return res"
  },
  {
    "title": "ZigZag Conversion",
    "link": "https://leetcode.com/problems/zigzag-conversion/",
    "keywords": [
      "#String",
      "#Array",
      "#Simulation"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We iterate through the input string of length N exactly once to place each character into its respective row."
      },
      "space": {
        "notation": "O(N)",
        "justification": "We create an auxiliary array of strings to store the characters. The total number of characters stored is equal to the length of the input string, N."
      }
    },
    "whiteboard": "This is a direct simulation problem. The most effective method is to create an array of strings, where each string represents a row. We iterate through the input string character by character, appending each one to the correct row. A pointer indicates the current row, and a direction variable (e.g., +1 for down, -1 for up) controls the movement. The direction flips whenever the pointer reaches the top or bottom row.",
    "dry_run": "Example: `s = \"PAYPAL\"`, `numRows = 3`\n1. `res = [\"\", \"\", \"\"]`, `row = 0`, `dir = 1`.\n2. 'P' -> `res[0]`. `row=1`.\n3. 'A' -> `res[1]`. `row=2`.\n4. 'Y' -> `res[2]`. At bottom, `dir=-1`. `row=1`.\n5. 'P' -> `res[1]`. `row=0`.\n6. 'A' -> `res[0]`. At top, `dir=1`. `row=1`.\n7. 'L' -> `res[1]`. Final `res=[\"PA\", \"YAPL\", \"\"]`. Join to `\"PAYAPL\"`.",
    "test_cases": "- `numRows = 1`.\n- `numRows` is greater than or equal to the string length.\n- Empty input string.",
    "ia_solution": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        # FORYOU!!: Explain the edge case handling up front.\n        # Answer: If there's only one row, or if the number of rows is enough to hold every character vertically, the string doesn't change, so we can return it immediately.\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        # Create a list of empty strings, one for each row.\n        rows = [\"\"] * numRows\n        current_row = 0\n        # Direction controls whether we're moving down (1) or up (-1) through the rows.\n        direction = -1\n        \n        for char in s:\n            rows[current_row] += char\n            \n            # If we're at the top or bottom row, reverse direction.\n            if current_row == 0 or current_row == numRows - 1:\n                direction *= -1\n            \n            current_row += direction\n            \n        # Join all the row strings to form the final result.\n        return \"\".join(rows)",
    "manual_solution": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        # If one row, or enough rows for every char, string doesn't change.\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        # Create a list of empty strings, one for each row.\n        res = [\"\"] * numRows\n        row = 0\n        # Direction controls whether we're moving down (1) or up (-1).\n        direction = 1\n        \n        for char in s:\n            res[row] += char\n            \n            # If we're at the top or bottom, reverse direction.\n            if row == 0:\n                direction = 1\n            elif row == numRows - 1:\n                direction = -1\n            \n            row += direction\n            \n        return \"\".join(res)"
  },
  {
    "title": "Reverse Integer",
    "link": "https://leetcode.com/problems/reverse-integer/",
    "keywords": [
      "#Math",
      "#IntegerOverflow"
    ],
    "complexity": {
      "time": {
        "notation": "O(log10(x))",
        "justification": "The number of iterations is equal to the number of digits in the integer x, which is proportional to log base 10 of x."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The solution uses a fixed number of variables to perform the reversal, regardless of the size of the input integer."
      }
    },
    "whiteboard": "The core of this problem is handling potential 32-bit integer overflow. The best approach is purely mathematical, avoiding string conversion. We can build the reversed integer digit by digit using the modulo (`%`) and division (`//`) operators. In each step, before we multiply our result by 10 and add the new digit, we must check if this operation would push the result beyond `INT_MAX` or `INT_MIN`. This pre-emptive check is the key to a correct solution.",
    "dry_run": "Example: `x = 123`\n1. `rev = 0`.\n2. Loop 1: `digit = 3`, `rev = 3`, `x = 12`.\n3. Loop 2: `digit = 2`, `rev = 32`, `x = 1`.\n4. Loop 3: `digit = 1`, `rev = 321`, `x = 0`.\n5. Loop ends. Return `321`.",
    "test_cases": "- Positive and negative integers.\n- Numbers ending in zero (e.g., `120`).\n- `x = 0`.\n- Numbers that will cause overflow when reversed (e.g., `1534236469`).\n- `INT_MIN` and `INT_MAX` themselves.",
    "ia_solution": "class Solution:\n    def reverse(self, x: int) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n        rev = 0\n        \n        sign = 1 if x >= 0 else -1\n        x = abs(x)\n\n        while x != 0:\n            digit = x % 10\n            x //= 10\n            \n            # FORYOU!!: This is the most critical part of the solution. Explain the overflow check in detail.\n            # Answer: Before we do `rev = rev * 10 + digit`, we check if `rev` is already so large that multiplying by 10 would exceed the limit. `INT_MAX // 10` is the largest number `rev` can be without overflowing. If `rev` is exactly that number, we also have to check if the incoming `digit` is greater than the last digit of `INT_MAX` (which is 7).\n            if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and digit > 7):\n                return 0\n            \n            rev = rev * 10 + digit\n            \n        return rev * sign",
    "manual_solution": "class Solution:\n    def reverse(self, x: int) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n        rev = 0\n        sign = 1 if x >= 0 else -1\n        x = abs(x)\n\n        while x != 0:\n            digit = x % 10\n            \n            # CRITICAL: Check for potential overflow BEFORE making the change.\n            if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and digit > 7):\n                return 0\n            \n            rev = rev * 10 + digit\n            x //= 10\n            \n        return rev * sign"
  },
  {
    "title": "String to Integer (atoi)",
    "link": "https://leetcode.com/problems/string-to-integer-atoi/",
    "keywords": [
      "#String",
      "#EdgeCases",
      "#FiniteStateMachine"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We perform a single pass over the input string of length N to parse the integer."
      },
      "space": {
        "notation": "O(1)",
        "justification": "We only use a few variables to keep track of the parsing state. The space required does not scale with the input string length."
      }
    },
    "whiteboard": "This problem tests meticulous handling of edge cases. It can be modeled as a finite state machine. The best approach is a manual, state-based parse: 1. Skip leading whitespace. 2. Check for an optional sign ('+' or '-'). 3. Read consecutive digits, building the number. 4. Stop at the first non-digit character. During step 3, it is crucial to check for integer overflow *before* adding the next digit. Finally, clamp the result to the 32-bit signed integer range.",
    "dry_run": "Example: `s = \"   -42\"`\n1. Skip 3 spaces. `i=3`.\n2. Read sign. `s[3]` is '-'. `sign = -1`. `i=4`.\n3. Read digits. `s[4]` is '4'. `res=4`. `i=5`. `s[5]` is '2'. `res=42`. `i=6`.\n4. `s[6]` is end of string. Loop terminates.\n5. Apply sign: `res = -42`. Return -42.",
    "test_cases": "- Leading/trailing whitespace.\n- Presence of '+' or '-' sign.\n- Strings with letters before or after numbers (e.g., 'words and 987').\n- Overflow and underflow cases.\n- Empty string or string with only whitespace.",
    "ia_solution": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n        i, n = 0, len(s)\n        res = 0\n        sign = 1\n        \n        # FORYOU!!: Frame this problem as a state machine. The states are: 1. Skipping Whitespace, 2. Reading Sign, 3. Reading Digits, 4. Done.\n        \n        # State 1: Skip leading whitespace\n        while i < n and s[i] == ' ':\n            i += 1\n            \n        # State 2: Determine sign\n        if i < n and (s[i] == '+' or s[i] == '-'):\n            if s[i] == '-':\n                sign = -1\n            i += 1\n            \n        # State 3: Read in digits until a non-digit is found\n        while i < n and s[i].isdigit():\n            digit = int(s[i])\n            \n            # CRITICAL: Check for overflow before multiplication, just like in Reverse Integer.\n            if res > INT_MAX // 10 or (res == INT_MAX // 10 and digit > 7):\n                return INT_MAX if sign == 1 else INT_MIN\n                \n            res = res * 10 + digit\n            i += 1\n            \n        # State 4: Done. Apply sign and return.\n        return sign * res",
    "manual_solution": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n        i, n = 0, len(s)\n        \n        # 1. Skip leading whitespace\n        while i < n and s[i] == ' ':\n            i += 1\n            \n        # 2. Determine sign\n        sign = 1\n        if i < n and (s[i] == '+' or s[i] == '-'):\n            if s[i] == '-':\n                sign = -1\n            i += 1\n            \n        # 3. Read in digits until a non-digit is found\n        res = 0\n        while i < n and s[i].isdigit():\n            digit = int(s[i])\n            \n            # CRITICAL: Check for overflow before multiplication\n            if res > INT_MAX // 10 or (res == INT_MAX // 10 and digit > 7):\n                return INT_MAX if sign == 1 else INT_MIN\n                \n            res = res * 10 + digit\n            i += 1\n            \n        # 4. Apply sign and return\n        return sign * res"
  },
  {
    "title": "Palindrome Number",
    "link": "https://leetcode.com/problems/palindrome-number/",
    "keywords": [
      "#Math",
      "#NoStringConversion"
    ],
    "complexity": {
      "time": {
        "notation": "O(log10(x))",
        "justification": "The mathematical approach iterates through roughly half the digits of the number x. The total number of digits is log10(x)."
      },
      "space": {
        "notation": "O(1)",
        "justification": "We only use a couple of variables to store the original number and the reversed half, requiring constant extra space."
      }
    },
    "whiteboard": "While converting the number to a string and checking for equality with its reverse is simple, interviewers often ask for a solution without string conversion. The mathematical approach is more efficient in terms of space (O(1)). It involves reversing only the second half of the number and comparing it with the first half. This avoids potential integer overflow issues that can arise from reversing the entire number if it's very large.",
    "dry_run": "Example: `x = 1221`\n1. `x` is positive and doesn't end in 0. OK.\n2. `reverted_half = 0`.\n3. Loop 1: `x=122`, `reverted_half=1`.\n4. Loop 2: `x=12`, `reverted_half=12`.\n5. Loop terminates as `x` is not > `reverted_half`.\n6. Compare `x == reverted_half` (`12 == 12`). It's true. Return `True`.",
    "test_cases": "- Negative numbers (should return False).\n- `0` (should return True).\n- Numbers ending in zero, but not zero itself (e.g., 10, 120 - should return False).\n- Even and odd length palindromes.",
    "ia_solution": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        # FORYOU!!: Be ready to explain why the `x % 10 == 0` check is important.\n        # Answer: A number greater than 0 that ends in 0 cannot be a palindrome, because a number cannot start with a 0 (e.g., 120 reversed is 021, which is just 21).\n        # Also, negative numbers are not palindromes by definition.\n        if x < 0 or (x > 0 and x % 10 == 0):\n            return False\n\n        reverted_half = 0\n        # We only need to revert the second half of the number.\n        # The loop stops when x is no longer greater than the reversed part.\n        while x > reverted_half:\n            reverted_half = reverted_half * 10 + x % 10\n            x //= 10\n\n        # For odd length numbers, the middle digit is on `reverted_half`, so we can remove it by integer division (e.g., 12321 -> x=12, rev=123 -> rev//10=12).\n        # For even length numbers, x will equal reverted_half.\n        return x == reverted_half or x == reverted_half // 10",
    "manual_solution": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        # A negative number cannot be a palindrome.\n        # Also, if a number ends in 0 (and is not 0), it cannot be a palindrome.\n        if x < 0 or (x > 0 and x % 10 == 0):\n            return False\n\n        reverted_half = 0\n        # We only need to revert the second half of the number.\n        while x > reverted_half:\n            reverted_half = reverted_half * 10 + x % 10\n            x //= 10\n\n        # For odd length numbers, the middle digit is irrelevant (e.g., 12321 -> x=12, rev=123).\n        # For even length, x will equal reverted_half.\n        return x == reverted_half or x == reverted_half // 10"
  },
  {
    "title": "Regular Expression Matching",
    "link": "https://leetcode.com/problems/regular-expression-matching/",
    "keywords": [
      "#String",
      "#DynamicProgramming",
      "#Recursion",
      "#Regex",
      "#Hard"
    ],
    "complexity": {
      "time": {
        "notation": "O(S * P)",
        "justification": "The dynamic programming solution fills a 2D table of size S x P, where S and P are the lengths of the string and pattern. Each cell calculation is a constant time operation."
      },
      "space": {
        "notation": "O(S * P)",
        "justification": "We create a DP table of size (S+1) x (P+1) to store the intermediate results of the matching process."
      }
    },
    "whiteboard": "This is a hard problem best solved with Dynamic Programming. A 2D DP table, `dp[i][j]`, can store whether the first `i` characters of the string `s` match the first `j` characters of the pattern `p`. The state transitions depend on the character in the pattern. If it's a normal character or '.', the match depends on the previous characters `dp[i-1][j-1]`. If it's a '*', it introduces two possibilities: the '*' matches zero preceding elements (depending on `dp[i][j-2]`), or it matches one or more (depending on `dp[i-1][j]`).",
    "dry_run": "Conceptual Dry Run: `s=\"aab\", p=\"c*a*b\"`.\n`dp[i][j]` = `s[:i]` matches `p[:j]`.\n`dp[0][0]` = True.\n`dp[0][2]` = True because `c*` can match an empty string.\n`dp[0][4]` = True because `c*a*` can match an empty string.\n`dp[1][4]` (`'a'` vs `'c*a*'`) = True because `a*` matches `'a'`. Depends on `dp[0][4]`.\n... work through the table until `dp[3][5]` is calculated.",
    "test_cases": "- `.` matching any character.\n- `*` matching zero elements.\n- `*` matching multiple elements.\n- Complex patterns like `a.*b`.\n- Empty string or empty pattern.",
    "ia_solution": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # FORYOU!!: This is a classic Dynamic Programming problem. Focus on explaining the DP state and transitions.\n        # DP State: `dp[i][j]` will be `True` if the first `i` characters of `s` match the first `j` characters of `p`.\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n\n        # Base case: empty string matches empty pattern.\n        dp[0][0] = True\n\n        # Handle patterns like \"a*\", \"a*b*\", etc., that can match an empty string.\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        # Fill the rest of the DP table.\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                # Case 1: The current pattern character is NOT '*'.\n                if p[j - 1] != '*':\n                    # Match depends on previous subproblem and if current characters match.\n                    if dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.'):\n                        dp[i][j] = True\n                # Case 2: The current pattern character IS '*'.\n                else:\n                    # Option A: '*' matches zero occurrences of the preceding element.\n                    # In this case, `p[j-2]*` is effectively ignored, so the result is the same as `dp[i][j-2]`.\n                    if dp[i][j - 2]:\n                        dp[i][j] = True\n                    # Option B: '*' matches one or more occurrences.\n                    # This is only possible if the current string char `s[i-1]` matches the char before the `*` (`p[j-2]`).\n                    # If so, the result depends on `dp[i-1][j]` (matching the previous string character with the same pattern).\n                    elif dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'):\n                        dp[i][j] = True\n\n        return dp[len(s)][len(p)]",
    "manual_solution": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # DP table initialized to False. dp[i][j] = s[:i] matches p[:j]\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n\n        # Base case: empty string matches empty pattern\n        dp[0][0] = True\n\n        # Handle patterns like \"a*\" that can match an empty string\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        # Fill the rest of the DP table\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] != '*':\n                    if dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.'):\n                        dp[i][j] = True\n                else:\n                    # Option A: '*' means zero occurrences\n                    if dp[i][j - 2]:\n                        dp[i][j] = True\n                    # Option B: '*' means one or more occurrences\n                    elif dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'):\n                        dp[i][j] = True\n\n        return dp[len(s)][len(p)]"
  },
  {
    "title": "Container With Most Water",
    "link": "https://leetcode.com/problems/container-with-most-water",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#Greedy"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We use a single pass with two pointers moving towards each other. Each pointer traverses the array exactly once, resulting in a linear time complexity."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The solution uses a constant amount of extra space for variables like `left`, `right`, and `mx`, regardless of the input array size."
      }
    },
    "whiteboard": "This problem is optimally solved using a two-pointer approach, which is a greedy algorithm. We initialize two pointers, `left` at the beginning and `right` at the end of the array. The width of the container is `right - left`, and the height is limited by the shorter of the two lines (`min(height[left], height[right])`). We calculate this area and keep track of the maximum area found.\n\nThe core insight is how to move the pointers. To potentially find a larger area, we must increase either the width or the height. Since we start at maximum width, the only way to increase the area is by finding a greater height. If we move the pointer of the taller line inwards, the new height will be at best the same as the shorter line, but the width will have decreased, guaranteeing the area cannot be larger. Therefore, we must move the pointer of the shorter line inwards, as this is the only move that holds the potential to find a taller line and thus a larger area. This greedy choice guarantees we never miss the optimal solution. A brute-force approach of checking every pair of lines would be O(N^2), making this two-pointer solution far more efficient.",
    "dry_run": "Example: `height = [1, 8, 6, 2, 5, 4, 8, 3, 7]`\n1. `left = 0`, `right = 8`. `width = 8`. `height = min(h[0], h[8]) = min(1, 7) = 1`. `area = 8 * 1 = 8`. `mx = 8`. `h[left] < h[right]`, so `left++`.\n2. `left = 1`, `right = 8`. `width = 7`. `height = min(h[1], h[8]) = min(8, 7) = 7`. `area = 7 * 7 = 49`. `mx = 49`. `h[left] > h[right]`, so `right--`.\n3. `left = 1`, `right = 7`. `width = 6`. `height = min(h[1], h[7]) = min(8, 3) = 3`. `area = 6 * 3 = 18`. `mx` is still `49`. `h[left] > h[right]`, so `right--`.\n4. ... The process continues until `left >= right`. The final answer is `49`.",
    "test_cases": "- Array where the tallest bars are at the ends.\n- Array where the tallest bars are in the middle.\n- Strictly increasing or decreasing array.\n- Array with only two elements.",
    "ia_solution": "class Solution:\n    def maxArea(self, height: list[int]) -> int:\n        # Initialize pointers at both ends of the array and max_area to 0.\n        left, right = 0, len(height) - 1\n        max_area = 0\n\n        # Loop until the pointers meet.\n        while left < right:\n            # Calculate the current area.\n            # Width is the distance between pointers.\n            # Height is limited by the shorter of the two lines.\n            current_area = (right - left) * min(height[left], height[right])\n            max_area = max(max_area, current_area)\n            \n            # FORYOU!!: Interviewer will ask for the logic behind which pointer to move.\n            # Answer: We move the pointer pointing to the shorter line because it's the limiting factor for the height. Moving the taller pointer would only decrease the width without any chance of increasing the container's height, thus guaranteeing a smaller or equal area. Moving the shorter pointer gives us a chance to find a taller line, potentially leading to a larger area.\n            if height[left] < height[right]: \n                left += 1\n            else: \n                right -= 1\n        return max_area",
    "manual_solution": "class Solution:\n    def maxArea(self, height):\n        # Initialize pointers at both ends of the array and max_area to 0.\n        left, right, mx = 0, len(height) - 1, 0\n\n        # Loop until the pointers meet.\n        while left < right:\n            # Calculate the current area.\n            # Width is the distance between pointers.\n            # Height is limited by the shorter of the two lines.\n            current_area = (right - left) * min(height[left], height[right])\n            mx = max(mx, current_area)\n            \n            # FORYOU!!: Interviewer will ask for the logic behind which pointer to move.\n            # Answer: We move the pointer pointing to the shorter line because it's the limiting factor for the height. Moving the taller pointer would only decrease the width without any chance of increasing the height, thus guaranteeing a smaller area. Moving the shorter pointer gives us a chance to find a taller line, potentially leading to a larger area.\n            if height[left] < height[right]: \n                left += 1\n            else: \n                right -= 1\n        return mx"
  },
  {
    "title": "Integer to Roman",
    "link": "https://leetcode.com/problems/integer-to-roman",
    "keywords": [
      "#String",
      "#Math",
      "#Mapping",
      "#Greedy"
    ],
    "complexity": {
      "time": {
        "notation": "O(1)",
        "justification": "The input integer is bounded (e.g., 1 to 3999). Therefore, the number of operations (divisions, modulo, string concatenations) is constant and does not scale with the magnitude of the input number."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The length of the resulting Roman numeral string is also bounded (e.g., 'MMMCMXCIX' is one of the longest). The space required does not grow with the input number's value."
      }
    },
    "whiteboard": "The most robust and readable way to solve this is with a greedy mapping approach. We create a list of pairs, mapping integer values to their Roman numeral symbols, sorted in descending order. This list must include the subtractive cases (like 900 for 'CM', 400 for 'CD', etc.).\n\nWe iterate through this list. For each value-symbol pair, we check how many times the value can be 'subtracted' from our input number. We append the corresponding symbol that many times to our result string and then update the number using the modulo operator. Because the list is sorted from largest to smallest, we greedily build the Roman numeral correctly.\n\nThe provided solution works by manually handling each place value (thousands, hundreds, tens, ones) with complex conditional logic. While it gets the correct answer, the mapping approach is much cleaner, less error-prone, and easier to explain in an interview.",
    "dry_run": "Example using the standard mapping method: `num = 58`\nMapping: `[(1000, 'M'), (900, 'CM'), ..., (50, 'L'), (40, 'XL'), (10, 'X'), ..., (1, 'I')]`\n1. `num = 58`. Check `1000`, `900`, ... down to `50`. `58 // 50 = 1`. Append 'L'. `num` becomes `8`.\n2. `num = 8`. Check `40`, `10`. `8 // 10 = 0`. ... `8 // 5 = 1`. Append 'V'. `num` becomes `3`.\n3. `num = 3`. Check `4`. `3 // 1 = 3`. Append 'I' three times. `num` becomes `0`.\n4. Loop ends. Final result: 'L' + 'V' + 'III' = 'LVIII'.",
    "test_cases": "- A number with subtractive cases (e.g., 1994 -> MCMXCIV).\n- A number with no subtractive cases (e.g., 3888 -> MMMDCCCLXXXVIII).\n- Edge cases like 4, 9, 40, 90.\n- The maximum number, 3999.",
    "ia_solution": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        # FORYOU!!: This mapping approach is much cleaner and easier to explain than manual logic for each digit place. It's the standard, expected solution.\n        # The list must be sorted in descending order and include subtractive pairs (900, 400, 90, 4) to handle those cases greedily.\n        val_map = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n            (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n            (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"),\n            (1, \"I\")\n        ]\n        \n        # This will store our final Roman numeral string.\n        res = []\n\n        # Greedily build the string from largest to smallest values.\n        for val, sym in val_map:\n            # See how many times this symbol fits into the remaining number.\n            if num == 0: break\n            count, num = divmod(num, val)\n            \n            # Append the symbol that many times.\n            res.append(sym * count)\n            \n        return \"\".join(res)",
    "manual_solution": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        # FORYOU!!: This mapping approach is much cleaner and easier to explain than manual logic for each digit place. It's the standard, expected solution.\n        # The list must be sorted in descending order and include subtractive pairs (900, 400, 90, 4) to handle those cases greedily.\n        val_map = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n            (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n            (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"),\n            (1, \"I\")\n        ]\n        \n        # This will store our final Roman numeral string.\n        res = \"\"\n\n        # Greedily build the string from largest to smallest values.\n        for val, sym in val_map:\n            # See how many times this symbol fits into the remaining number.\n            count = num // val\n            \n            # Append the symbol that many times.\n            res += sym * count\n            \n            # Update the number to the remainder.\n            num %= val\n            \n        return res"
  },
  {
    "title": "Roman to Integer",
    "link": "https://leetcode.com/problems/roman-to-integer",
    "keywords": [
      "#String",
      "#HashTable",
      "#Mapping"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "The solution involves a single pass through the input string of length N. The hash map lookup is an O(1) operation."
      },
      "space": {
        "notation": "O(1)",
        "justification": "A hash map is used to store the values of the Roman numerals, but its size is constant (7 key-value pairs) and does not depend on the input string's length."
      }
    },
    "whiteboard": "The key to this problem is understanding the subtractive rule in Roman numerals, where a smaller value preceding a larger one means subtraction (e.g., 'IV' is 4, not 6). A clever way to handle this is to iterate through the string from right to left.\n\nWe use a hash map to store the integer value of each Roman symbol for quick O(1) lookups. As we iterate from the end, we keep track of the value of the previously seen character. For the current character, if its value is less than the previous one, we subtract it from our total sum (this handles cases like 'I' in 'IV'). Otherwise, we add its value to the sum. This approach correctly accumulates the total by elegantly handling both additive and subtractive cases in a single pass.",
    "dry_run": "Example: `s = \"MCMXCIV\"`\nMap: `{'I':1, 'V':5, 'X':10, 'C':100, 'M':1000}`\nIterate from right to left:\n1. `char = 'V'`. `pre_val = 1` (from 'I'). `val(V) = 5 > 1`. `sum = 5 - 1 = 4`. `pre_val = 5`.\n2. `char = 'C'`. `pre_val = 5`. `val(C) = 100 > 5`. `sum = 4 + 100 = 104`. `pre_val = 100`.\n3. `char = 'X'`. `pre_val = 100`. `val(X) = 10 < 100`. `sum = 104 - 10 = 94`. `pre_val = 10`.\n4. `char = 'M'`. `pre_val = 10`. `val(M) = 1000 > 10`. `sum = 94 + 1000 = 1094`. `pre_val = 1000`.\n5. `char = 'C'`. `pre_val = 1000`. `val(C) = 100 < 1000`. `sum = 1094 - 100 = 994`. `pre_val = 100`.\n6. `char = 'M'`. `pre_val = 100`. `val(M) = 1000 > 100`. `sum = 994 + 1000 = 1994`. `pre_val = 1000`.\nFinal result: `1994`.",
    "test_cases": "- Simple additive case (e.g., 'LVIII').\n- Simple subtractive case (e.g., 'IV').\n- Complex case with multiple subtractions (e.g., 'MCMXCIV').\n- Single character input (e.g., 'X').",
    "ia_solution": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        # Hash map for O(1) value lookups.\n        table = {\"M\": 1000, \"D\": 500, \"C\": 100, \"L\": 50, \"X\": 10, \"V\": 5, \"I\": 1}\n        \n        total = 0\n        prev_val = 0\n\n        # FORYOU!!: Explain why iterating from right-to-left is a good strategy.\n        # Answer: It simplifies handling the subtractive rule. When we see a character, we only need to compare it with the one immediately to its right (which we've already processed). If the current character's value is smaller, we know it's a subtraction. This avoids complex lookaheads required by a left-to-right scan.\n        for char in reversed(s):\n            cur_val = table[char]\n            # If the current value is less than the previous (value to its right),\n            # it's a subtractive case like 'IV' (1 before 5) or 'IX' (1 before 10).\n            if cur_val < prev_val:\n                total -= cur_val\n            else:\n                # Otherwise, it's an additive case.\n                total += cur_val\n            # Update the previous value for the next iteration.\n            prev_val = cur_val\n            \n        return total",
    "manual_solution": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        # Hash map for O(1) value lookups.\n        table = {\"M\": 1000, \"D\": 500, \"C\": 100, \"L\": 50, \"X\": 10, \"V\": 5, \"I\": 1}\n        \n        sm = 0\n        pre_val = 0\n\n        # FORYOU!!: Explain why iterating from right-to-left is a good strategy.\n        # Answer: It simplifies handling the subtractive rule. When we see a character, we only need to compare it with the one immediately to its right (which we've already processed). If the current character is smaller, we know it's a subtraction. This avoids complex lookaheads.\n        for c in s[::-1]: \n            cur_val = table[c]\n            # If the current value is less than the previous (value to its right),\n            # it's a subtractive case like 'IV' (1 before 5) or 'IX' (1 before 10).\n            if cur_val < pre_val:\n                sm -= cur_val\n            else:\n                # Otherwise, it's an additive case.\n                sm += cur_val\n            # Update the previous value for the next iteration.\n            pre_val = cur_val\n            \n        return sm"
  },
  {
    "title": "Longest Common Prefix",
    "link": "https://leetcode.com/problems/longest-common-prefix",
    "keywords": [
      "#String",
      "#Array",
      "#VerticalScanning"
    ],
    "complexity": {
      "time": {
        "notation": "O(S)",
        "justification": "Where S is the total number of characters in all strings. In the worst-case scenario (all strings are identical), we must check every character. This can also be expressed as O(N * M), where N is the number of strings and M is the length of the shortest string."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The algorithm uses a constant amount of extra space. The result is a substring of the first input string, which doesn't count as extra space proportional to the input size."
      }
    },
    "whiteboard": "There are several ways to approach this, but one of the most efficient and straightforward is 'Vertical Scanning'. We imagine the strings arranged in a grid and scan downwards column by column.\n\nWe iterate with an index `j` from `0` to the length of the first string. In each iteration, we check if the character `strs[0][j]` is the same for all other strings at that same index `j`. If we find a mismatch or if any string is shorter than index `j`, we know the common prefix ends at the previous character. We can then return the slice of the first string up to index `j`.\n\nAn alternative is sorting the array of strings first. The longest common prefix of all strings will be the common prefix between the very first and very last strings in the sorted list. This is because sorting groups strings lexicographically, so the most different strings will be at the extremes.",
    "dry_run": "Example: `s = [\"flower\", \"flow\", \"flight\"]`\n1. `j = 0`. Character is 'f'. 'f' is at index 0 in all strings. OK. `j` becomes `1`.\n2. `j = 1`. Character is 'l'. 'l' is at index 1 in all strings. OK. `j` becomes `2`.\n3. `j = 2`. Character is 'o'. 'o' is at index 2 in \"flower\" and \"flow\", but \"flight\" has 'i'. Mismatch.\n4. The loop terminates. The common prefix is the part of the first string up to index `j=2`. Return `s[0][:2]`, which is `\"fl\"`.",
    "test_cases": "- An empty list of strings. Should return \"\".\n- A list with one string. Should return the string itself.\n- All strings are identical.\n- No common prefix exists. Should return \"\".\n- List contains an empty string.",
    "ia_solution": "class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -> str:\n        # Handle the edge case of an empty input list.\n        if not strs:\n            return \"\"\n        \n        # FORYOU!!: This is the 'Vertical Scanning' approach. Be ready to explain it and its alternative.\n        # Answer: We iterate through the characters of the first string (column by column) and for each character, we verify it against all other strings at the same position. This is efficient because it stops at the very first mismatch. An alternative is to sort the array and compare only the first and last strings, as they will be the most different lexicographically.\n\n        # Loop through each character index of the first string.\n        for i, char_to_match in enumerate(strs[0]):\n            # Loop through the rest of the strings to compare.\n            for other_str in strs[1:]:\n                # The two failure conditions:\n                # 1. The current string `other_str` is shorter than the prefix we're checking.\n                # 2. The character at index `i` does not match.\n                if i >= len(other_str) or other_str[i] != char_to_match:\n                    # If we fail, the prefix is the first string up to the current index `i`.\n                    return strs[0][:i]\n\n        # If the outer loop completes, it means the entire first string is a common prefix.\n        return strs[0]",
    "manual_solution": "class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -> str:\n        # Handle the edge case of an empty input list.\n        if not strs:\n            return \"\"\n        \n        # FORYOU!!: This is the 'Vertical Scanning' approach. Be ready to explain it.\n        # Answer: We iterate through the characters of the first string (column by column) and for each character, we verify it against all other strings at the same position. This is efficient because it stops at the very first mismatch found.\n\n        # Loop through each character index of the first string.\n        for j in range(len(strs[0])):\n            char_to_match = strs[0][j]\n            \n            # Loop through the rest of the strings to compare.\n            for i in range(1, len(strs)):\n                # The two failure conditions:\n                # 1. The current string `strs[i]` is shorter than the prefix we're checking.\n                # 2. The character at index `j` does not match.\n                if j >= len(strs[i]) or strs[i][j] != char_to_match:\n                    # If we fail, the prefix is the first string up to the current index `j`.\n                    return strs[0][:j]\n\n        # If the outer loop completes, it means the entire first string is a common prefix.\n        return strs[0]"
  },
  {
    "title": "3Sum",
    "link": "https://leetcode.com/problems/3sum",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#Sorting"
    ],
    "complexity": {
      "time": {
        "notation": "O(N^2)",
        "justification": "The initial sort of the array takes O(N log N). The main part of the algorithm is a loop that iterates through N elements, and inside it, a two-pointer approach that takes O(N) time. This results in a dominant time complexity of O(N^2)."
      },
      "space": {
        "notation": "O(N)",
        "justification": "The space complexity depends on the sorting algorithm used. A typical in-place quicksort uses O(log N) stack space, but can be O(N) in the worst case. The space for the result list can also be significant but is usually not counted as extra space. I'll state O(N) to be safe for sorting."
      }
    },
    "whiteboard": "A brute-force solution would check every combination of three numbers, leading to an O(N^3) complexity, which is too slow. The key to an optimized solution is to first sort the input array. Sorting takes O(N log N) but enables a much faster search.\n\nAfter sorting, we iterate through the array with a single pointer `i`. For each `nums[i]`, we need to find two other numbers in the rest of the array (from `i+1` to the end) that sum up to `-nums[i]`. This sub-problem is now the classic 'Two Sum' on a sorted array.\n\nWe solve this sub-problem using two pointers, `l` (left) starting at `i+1` and `r` (right) starting at the end of the array. We calculate the sum `nums[i] + nums[l] + nums[r]`. \n- If the sum is less than zero, we need a larger value, so we increment `l`.\n- If the sum is greater than zero, we need a smaller value, so we decrement `r`.\n- If the sum is zero, we've found a triplet. We add it to our results and move both pointers to search for new pairs.\n\nA crucial step is to handle duplicates. After finding a valid triplet, we must advance our pointers past any subsequent identical elements to ensure each unique triplet is found only once. We also skip duplicates for the initial `i` pointer.",
    "dry_run": "Example: `nums = [-1, 0, 1, 2, -1, -4]`\n1. Sort `nums`: `[-4, -1, -1, 0, 1, 2]`.\n2. `i = 0`, `nums[i] = -4`. `l=1`, `r=5`. Target sum is `4`. `(-1) + 2 = 1 < 4`, so `l++`. `(-1) + 2 = 1 < 4`, `l++`. `0 + 2 = 2 < 4`, `l++`. `1 + 2 = 3 < 4`, `l++`. `l` meets `r`. No solution for `i=0`.\n3. `i = 1`, `nums[i] = -1`. `l=2`, `r=5`. Target sum is `1`. `nums[l]+nums[r] = (-1) + 2 = 1`. Match! Found `[-1, -1, 2]`. Add to results. `l++`, `r--`.\n4. `l=3`, `r=4`. `nums[l]+nums[r] = 0 + 1 = 1`. Match! Found `[-1, 0, 1]`. Add to results. `l++`, `r--`. `l` meets `r`.\n5. `i = 2`, `nums[i] = -1`. This is a duplicate of the previous `i`, so we skip it.\n6. ... and so on. Final result: `[[-1, -1, 2], [-1, 0, 1]]`.",
    "test_cases": "- Array with no solution.\n- Array with many duplicates and zeros.\n- Array where multiple solutions exist for a single `i`.\n- Array is already sorted.",
    "ia_solution": "class Solution:\n    def threeSum(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        # FORYOU!!: The first and most critical step is sorting. Why?\n        # Answer: Sorting takes O(N log N), but it allows us to use the two-pointer technique for the inner search. With a sorted array, we can intelligently move the left and right pointers inwards to find the target sum in O(N) time for each fixed element, which would be impossible in an unsorted array without using extra space (like a hash map).\n        nums.sort()\n\n        # Iterate through the array to pick the first number of the triplet.\n        for i, a in enumerate(nums):\n            # Skip duplicate values for the first number to avoid duplicate triplets.\n            if i > 0 and a == nums[i-1]:\n                continue\n\n            # Use two pointers for the rest of the array.\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    # Sum is too big, need a smaller number, so move right pointer left.\n                    r -= 1\n                elif threeSum < 0:\n                    # Sum is too small, need a larger number, so move left pointer right.\n                    l += 1\n                else:\n                    # Found a triplet!\n                    res.append([a, nums[l], nums[r]])\n                    # Move left pointer forward to search for a new pair.\n                    l += 1\n                    # Skip duplicates for the second number to ensure uniqueness.\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n        return res",
    "manual_solution": "class Solution:\n    def threeSum(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        # FORYOU!!: The first and most critical step is sorting. Why?\n        # Answer: Sorting allows us to use the two-pointer technique. With a sorted array, we can intelligently move the left and right pointers inwards to find the target sum in O(N) time, which would be impossible in an unsorted array without using extra space (like a hash map).\n        nums.sort()\n\n        # Iterate through the array to pick the first number of the triplet.\n        for i in range(len(nums) - 2):\n            # Skip duplicate values for the first number to avoid duplicate triplets.\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            # Use two pointers for the rest of the array.\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    # Sum is too small, need a larger number, so move left pointer right.\n                    l += 1\n                elif s > 0:\n                    # Sum is too big, need a smaller number, so move right pointer left.\n                    r -= 1\n                else:\n                    # Found a triplet!\n                    res.append([nums[i], nums[l], nums[r]])\n                    # Skip duplicates for the second and third numbers.\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    # Move pointers to find the next unique pair.\n                    l += 1\n                    r -= 1\n        return res"
  },
  {
    "title": "3Sum Closest",
    "link": "https://leetcode.com/problems/3sum-closest",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#Sorting"
    ],
    "complexity": {
      "time": {
        "notation": "O(N^2)",
        "justification": "Similar to 3Sum, the solution is dominated by the nested loop structure (a for loop and a two-pointer while loop) after an initial O(N log N) sort."
      },
      "space": {
        "notation": "O(N)",
        "justification": "Space is required for the sorting algorithm. Typically O(log N) for an in-place sort's recursion stack, but can be O(N) in worst-case scenarios."
      }
    },
    "whiteboard": "This problem is a variation of 3Sum and uses the exact same core algorithm: sorting followed by a two-pointer approach. The key difference is the objective. Instead of finding a sum that exactly equals a target, we want to find a sum that is closest to it.\n\nWe initialize a variable, `closest_sum`, to a very large value. After sorting the array, we iterate through it with a pointer `i`. For each `nums[i]`, we use two pointers, `l` and `r`, to scan the rest of the array. We compute the `current_sum = nums[i] + nums[l] + nums[r]`.\n\nAt each step, we compare the absolute difference `|current_sum - target|` with our smallest difference found so far. If the new difference is smaller, we update our `closest_sum` to be the `current_sum`.\n\nThe logic for moving the pointers remains the same as in Two Sum: if `current_sum` is less than the `target`, we increment `l` to get a larger sum. If it's greater, we decrement `r` to get a smaller sum. If the sum is exactly the target, we have found the absolute closest sum and can return it immediately.",
    "dry_run": "Example: `nums = [-1, 2, 1, -4]`, `target = 1`\n1. Sort `nums`: `[-4, -1, 1, 2]`.\n2. Initialize `diff = infinity`, `res = infinity`.\n3. `i = 0`, `nums[i] = -4`. `l=1`, `r=3`. `sum = -4 + (-1) + 2 = -3`. `| -3 - 1| = 4`. `diff = 4`, `res = -3`. `sum < target`, so `l++`.\n4. `i = 0`, `l=2`, `r=3`. `sum = -4 + 1 + 2 = -1`. `| -1 - 1| = 2`. `diff = 2`, `res = -1`. `sum < target`, so `l++`. `l` meets `r`.\n5. `i = 1`, `nums[i] = -1`. `l=2`, `r=3`. `sum = -1 + 1 + 2 = 2`. `|2 - 1| = 1`. `diff = 1`, `res = 2`. `sum > target`, so `r--`. `l` meets `r`.\n6. Loop finishes. The closest sum found was `2`.",
    "test_cases": "- An exact match for the target exists.\n- All numbers are positive or all are negative.\n- The closest sum is smaller than the target.\n- The closest sum is larger than the target.\n- Array contains duplicates.",
    "ia_solution": "class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -> int:\n        # FORYOU!!: This is a direct variation of 3Sum. The core logic (sort + two pointers) is identical. Emphasize that you recognize the pattern.\n        nums.sort()\n        # Initialize result with a sum of the first three numbers as a baseline.\n        res = nums[0] + nums[1] + nums[2]\n\n        for i in range(len(nums) - 2):\n            # Skip duplicates for the first element.\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                current_sum = nums[i] + nums[l] + nums[r]\n\n                # If we find an exact match, it's the closest possible. Return immediately.\n                if current_sum == target:\n                    return target\n\n                # Check if this sum is closer than the best we've found so far.\n                if abs(current_sum - target) < abs(res - target):\n                    res = current_sum\n\n                # Move pointers based on comparison with the target, just like in 2-Sum.\n                if current_sum < target:\n                    l += 1\n                else:\n                    r -= 1\n        return res",
    "manual_solution": "class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -> int:\n        # Initialize diff to infinity and the result.\n        diff = float(\"inf\")\n        res = 0 # Will be updated on first iteration.\n\n        # FORYOU!!: Same as 3Sum, sorting is the crucial first step.\n        # Answer: It enables the O(N) two-pointer scan for each element, bringing the total complexity down from O(N^3) to O(N^2).\n        nums.sort()\n\n        for i in range(len(nums) - 2):\n            # Skip duplicates for the first element.\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                sm = nums[i] + nums[l] + nums[r]\n\n                # Check if this sum is closer than the best we've found so far.\n                if abs(sm - target) < diff:\n                    diff = abs(sm - target)\n                    res = sm\n\n                # Move pointers based on comparison with the target.\n                if sm < target:\n                    l += 1\n                elif sm > target:\n                    r -= 1\n                else:\n                    # If sum is exactly the target, this is the closest possible. Return immediately.\n                    return res\n        return res"
  },
  {
    "title": "Letter Combinations of a Phone Number",
    "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number",
    "keywords": [
      "#String",
      "#Backtracking",
      "#Recursion",
      "#Iteration"
    ],
    "complexity": {
      "time": {
        "notation": "O(4^N * N)",
        "justification": "Where N is the length of the input digits string. For each digit, we have up to 4 choices (for '7' and '9'). This branching creates O(4^N) combinations. Each combination has a length of N, and creating it (e.g., via string concatenation) can take O(N) time, leading to the final complexity."
      },
      "space": {
        "notation": "O(4^N * N)",
        "justification": "The space is required to store the output. There are O(4^N) combinations, and each has length N. Additionally, the recursion stack for a backtracking solution would go N levels deep, using O(N) space."
      }
    },
    "whiteboard": "This is a classic backtracking problem. Backtracking is a recursive technique for solving problems by trying to build a solution incrementally, one piece at a time, and removing those solutions that fail to satisfy the constraints of the problem at any point in time.\n\nWe can define a recursive helper function, say `backtrack(index, current_string)`. The `index` tracks which digit we're currently processing, and `current_string` is the combination we've built so far.\nThe base case for the recursion is when `index` equals the length of the input digits. This means we've formed a complete combination, so we add `current_string` to our results list.\nIn the recursive step, we get the letters corresponding to the digit at the current `index`. We then loop through these letters. For each letter, we append it to `current_string` and make a recursive call for the next index: `backtrack(index + 1, current_string + letter)`.\n\nAn iterative solution using a queue (similar to Breadth-First Search) is also possible. You start with an empty string in the queue. For each digit, you dequeue all current combinations, append each possible new letter, and enqueue the new, longer combinations.",
    "dry_run": "Example using backtracking: `digits = \"23\"`\n`backtrack(index, path)`\n1. Call `backtrack(0, \"\")`.\n2. `index=0`, `digit='2'`, letters are `'a', 'b', 'c'`.\n3. Loop 1: Call `backtrack(1, \"a\")`.\n   - `index=1`, `digit='3'`, letters are `'d', 'e', 'f'`.\n   - Loop 1.1: Call `backtrack(2, \"ad\")`. Base case hit (`index=2`). Add \"ad\" to results.\n   - Loop 1.2: Call `backtrack(2, \"ae\")`. Base case hit. Add \"ae\".\n   - Loop 1.3: Call `backtrack(2, \"af\")`. Base case hit. Add \"af\".\n   - Return from `backtrack(1, \"a\")`.\n4. Loop 2: Call `backtrack(1, \"b\")`.\n   - ... adds \"bd\", \"be\", \"bf\".\n5. Loop 3: Call `backtrack(1, \"c\")`.\n   - ... adds \"cd\", \"ce\", \"cf\".\n6. Final result: `[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]`.",
    "test_cases": "- Empty input string. Should return [].\n- Single digit input.\n- Input with digits that map to 3 letters and digits that map to 4 letters.",
    "ia_solution": "class Solution:\n    def letterCombinations(self, digits: str) -> list[str]:\n        # Handle the edge case of an empty input string.\n        if not digits:\n            return []\n        \n        res = []\n        dic = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \n               '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        \n        # FORYOU!!: Be prepared to explain the backtracking approach.\n        # Answer: Backtracking is a recursive algorithm that explores all possible solutions by building a candidate solution step-by-step. When a step leads to a dead end or an invalid solution, it \"backtracks\" to the previous step and tries a different path. Here, each recursive call explores adding one more letter to our combination.\n        def backtrack(index, path):\n            # Base Case: If our path is the same length as the input digits,\n            # we have formed a complete combination.\n            if len(path) == len(digits):\n                res.append(\"\".join(path))\n                return\n            \n            # Recursive Step:\n            # Get the letters for the current digit.\n            possible_letters = dic[digits[index]]\n            # Loop through the letters and make a recursive call for each one.\n            for letter in possible_letters:\n                # Choose: Add the letter to the current path.\n                path.append(letter)\n                # Explore: Move to the next digit.\n                backtrack(index + 1, path)\n                # Unchoose (Backtrack): Remove the letter to try the next one in the loop.\n                path.pop()\n        \n        # Start the backtracking process from the first digit (index 0) with an empty path.\n        backtrack(0, [])\n        return res",
    "manual_solution": "class Solution:\n    def letterCombinations(self, digits: str) -> list[str]:\n        # Handle the edge case of an empty input string.\n        if not digits:\n            return []\n        \n        res = []\n        dic = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        \n        # FORYOU!!: Be prepared to explain the backtracking approach.\n        # Answer: Backtracking is a recursive algorithm that explores all possible solutions by building a candidate solution step-by-step. When a step leads to a dead end or an invalid solution, it \"backtracks\" to the previous step and tries a different path. Here, each recursive call explores adding one more letter to our combination.\n        def backtrack(index, path):\n            # Base Case: If our path is the same length as the input digits,\n            # we have formed a complete combination.\n            if index == len(digits):\n                res.append(path)\n                return\n            \n            # Recursive Step:\n            # Get the letters for the current digit.\n            letters = dic[digits[index]]\n            # Loop through the letters and make a recursive call for each one.\n            for letter in letters:\n                # The new path is the old path plus the new letter.\n                # The new index moves to the next digit.\n                backtrack(index + 1, path + letter)\n        \n        # Start the backtracking process from the first digit (index 0) with an empty path.\n        backtrack(0, \"\")\n        return res"
  },
  {
    "title": "4Sum",
    "link": "https://leetcode.com/problems/4sum",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#Sorting",
      "#KSum"
    ],
    "complexity": {
      "time": {
        "notation": "O(N^3)",
        "justification": "After an O(N log N) sort, we have three nested loops. Two explicit `for` loops to fix the first two numbers, and a third implicit loop from the two-pointer scan, which takes O(N) time. This results in a cubic time complexity."
      },
      "space": {
        "notation": "O(N)",
        "justification": "Space is primarily for the sorting algorithm's recursion stack (typically O(log N), worst-case O(N)). The result storage does not count towards auxiliary space complexity."
      }
    },
    "whiteboard": "This problem is a direct extension of 3Sum. The most effective approach is to reduce it to a series of 3Sum (or 2Sum) problems. First, as with all K-Sum problems, we sort the array.\n\nWe use two nested `for` loops to fix the first two numbers of the potential quadruplet, `nums[i]` and `nums[j]`. For each fixed pair, the problem is now reduced to finding two numbers in the rest of the array (`from j+1 to the end`) that sum to a new target: `target - nums[i] - nums[j]`. This is the classic 'Two Sum on a sorted array' problem, which we solve efficiently using the two-pointer technique (`l` and `r`).\n\nDuplicate handling is critical and more complex than in 3Sum. We need to skip duplicates for the `i` pointer, the `j` pointer, and also for the `l` and `r` pointers after a valid quadruplet is found. This ensures that each unique combination is added to the result list only once.",
    "dry_run": "Example: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`\n1. Sort `nums`: `[-2, -1, 0, 0, 1, 2]`\n2. `i = 0`, `nums[i] = -2`.\n   - `j = 1`, `nums[j] = -1`. `new_target = 0 - (-2) - (-1) = 3`. Use two pointers on `[0, 0, 1, 2]`. `l=2, r=5`. `0+2=2 < 3`, `l++`. `0+2=2 < 3`, `l++`. `1+2=3`. Match! Found `[-2, -1, 1, 2]`. Add to results. `l++`, `r--`.\n3. `i = 0`, `nums[i] = -2`.\n   - `j = 2`, `nums[j] = 0`. `new_target = 0 - (-2) - 0 = 2`. Use two pointers on `[0, 1, 2]`. `l=3, r=5`. `0+2=2`. Match! Found `[-2, 0, 0, 2]`. Add to results.\n4. ... The process continues, skipping duplicates, until all combinations are checked. Final result could also include `[-1, 0, 0, 1]`.",
    "test_cases": "- No solution exists.\n- Multiple solutions exist.\n- Array contains many duplicates, positive numbers, negative numbers, and zeros.\n- The target is a large positive or negative number.",
    "ia_solution": "class Solution:\n    def fourSum(self, nums: list[int], target: int) -> list[list[int]]:\n        res = []\n        # FORYOU!!: Explain how this problem can be generalized to a recursive K-Sum solution.\n        # Answer: You can write a recursive function, `kSum(nums, target, k)`. The base case is when k=2, where you solve it with the standard two-pointer approach. For k > 2, you iterate through the numbers, and for each number `n`, you recursively call `kSum` on the rest of the array with `target-n` and `k-1`. Sorting is required at the beginning, and duplicate handling is needed at each level of recursion.\n        nums.sort()\n\n        # First loop to fix the first number.\n        for i in range(len(nums) - 3):\n            # Skip duplicates for the first number.\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            # Second loop to fix the second number.\n            for j in range(i + 1, len(nums) - 2):\n                # Skip duplicates for the second number.\n                if j > i + 1 and nums[j] == nums[j-1]:\n                    continue\n\n                # Now we have a 2-Sum problem for the rest of the array.\n                l, r = j + 1, len(nums) - 1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s < target:\n                        l += 1\n                    elif s > target:\n                        r -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        # Skip duplicates for the third and fourth numbers.\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n        return res",
    "manual_solution": "class Solution:\n    def fourSum(self, nums: list[int], target: int) -> list[list[int]]:\n        res = []\n        # FORYOU!!: Explain how this problem can be generalized to K-Sum.\n        # Answer: You can write a recursive function, `kSum(nums, target, k)`. The base case is when k=2, where you solve it with the standard two-pointer approach. For k > 2, you iterate through the numbers, and for each number `n`, you recursively call `kSum` on the rest of the array with `target-n` and `k-1`. Sorting is required at the beginning, and duplicate handling is needed at each level of recursion.\n        nums.sort()\n\n        # First loop to fix the first number.\n        for i in range(len(nums) - 3):\n            # Skip duplicates for the first number.\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            # Second loop to fix the second number.\n            for j in range(i + 1, len(nums) - 2):\n                # Skip duplicates for the second number.\n                if j > i + 1 and nums[j] == nums[j-1]:\n                    continue\n\n                # Now we have a 2-Sum problem for the rest of the array.\n                l, r = j + 1, len(nums) - 1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s < target:\n                        l += 1\n                    elif s > target:\n                        r -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        # Skip duplicates for the third and fourth numbers.\n                        while l < r and nums[l] == nums[l+1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r-1]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n        return res"
  },
  {
    "title": "Remove Nth Node From End of List",
    "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list",
    "keywords": [
      "#LinkedList",
      "#TwoPointers",
      "#DummyNode"
    ],
    "complexity": {
      "time": {
        "notation": "O(L)",
        "justification": "Where L is the length of the linked list. The algorithm requires a single pass through the list with two pointers."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The optimal two-pointer solution uses a constant amount of extra space (for the two pointers and a dummy node)."
      }
    },
    "whiteboard": "The most elegant solution to this problem uses the two-pointer technique. A naive approach might be to traverse the list once to find its length (L), then traverse it again `L-n` times to find the node to remove. The two-pointer method accomplishes this in a single pass.\n\nFirst, we introduce a `dummy` node that points to the head. This is a crucial trick that simplifies handling edge cases, like removing the actual head of the list.\n\nWe initialize two pointers, `fast` and `slow`, both starting at the `dummy` node. We first advance the `fast` pointer `n+1` steps ahead. The `+1` is so that the `slow` pointer will end up on the node *before* the one we want to delete.\n\nAfter this initial gap is created, we move both `fast` and `slow` pointers one step at a time until `fast` reaches the end of the list (i.e., `fast` is `None`). At this point, `slow` will be positioned exactly before the target node. We can then remove the target node by updating the `next` reference: `slow.next = slow.next.next`.\nFinally, we return `dummy.next`, which is the head of the modified list.",
    "dry_run": "Example: `head = [1,2,3,4,5]`, `n = 2`\n1. Create `dummy` node: `dummy -> 1 -> 2 -> 3 -> 4 -> 5`.\n2. `fast` and `slow` start at `dummy`.\n3. Move `fast` `n+1 = 3` steps ahead. `fast` now points to node `3`. `slow` is still at `dummy`.\n   `slow`\n    ↓\n`dummy -> 1 -> 2 -> 3 -> 4 -> 5`\n                   ↑\n                  `fast`\n4. Now, move `fast` and `slow` together until `fast` reaches the end.\n   - `fast` -> `4`, `slow` -> `1`\n   - `fast` -> `5`, `slow` -> `2`\n   - `fast` -> `None`, `slow` -> `3`. Loop terminates.\n5. `slow` is pointing at node `3`. We need to remove the next node (node `4`).\n6. Execute `slow.next = slow.next.next`. This changes `3.next` from `4` to `5`.\n7. The list is now `dummy -> 1 -> 2 -> 3 -> 5`.\n8. Return `dummy.next`.",
    "test_cases": "- Removing the head of the list (e.g., `n` = length of list).\n- Removing the tail of the list (e.g., `n = 1`).\n- List with only one node, and `n = 1`.\n- A long list.",
    "ia_solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # FORYOU!!: Always mention using a dummy node and explain why.\n        # Answer: A dummy node simplifies edge cases, particularly when we need to remove the head of the list. Without it, we would need special conditional logic to handle the case where the node to be removed is the first one.\n        dummy = ListNode(0, head)\n        slow = dummy\n        fast = dummy\n        \n        # Advance the fast pointer to create a gap of 'n' nodes between fast and slow.\n        # We move it n+1 steps so that slow will land on the node *before* the target node.\n        for _ in range(n + 1):\n            fast = fast.next\n            \n        # Move both pointers simultaneously until the fast pointer reaches the end of the list.\n        while fast:\n            slow = slow.next\n            fast = fast.next\n            \n        # At this point, 'slow' is the node just before the one we want to remove.\n        # We bypass the target node to effectively delete it.\n        slow.next = slow.next.next\n        \n        # The dummy node's next pointer points to the head of the modified list.\n        return dummy.next",
    "manual_solution": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # FORYOU!!: Always mention using a dummy node and explain why.\n        # Answer: A dummy node simplifies edge cases, particularly when we need to remove the head of the list. Without it, we would need special conditional logic to handle the case where the node to be removed is the first one.\n        dummy = ListNode(0, head)\n        slow = dummy\n        fast = dummy\n        \n        # Advance the fast pointer to create a gap of 'n' nodes between fast and slow.\n        # We move it n+1 steps so that slow will land on the node *before* the target node.\n        for _ in range(n + 1):\n            fast = fast.next\n            \n        # Move both pointers simultaneously until the fast pointer reaches the end of the list.\n        while fast:\n            slow = slow.next\n            fast = fast.next\n            \n        # At this point, 'slow' is the node just before the one we want to remove.\n        # We bypass the target node to effectively delete it.\n        slow.next = slow.next.next\n        \n        # The dummy node's next pointer points to the head of the modified list.\n        return dummy.next"
  },
  {
    "title": "Valid Parentheses",
    "link": "https://leetcode.com/problems/valid-parentheses",
    "keywords": [
      "#String",
      "#Stack",
      "#HashTable"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We iterate through the input string of length N exactly once. Stack push and pop operations are O(1)."
      },
      "space": {
        "notation": "O(N)",
        "justification": "In the worst-case scenario, the input string consists only of opening brackets (e.g., '((({{{'). In this case, the stack would grow to a size of N."
      }
    },
    "whiteboard": "This problem is a perfect use case for a Stack data structure. The Last-In, First-Out (LIFO) nature of a stack mirrors how parentheses must be closed in the reverse order they are opened.\n\nThe algorithm is as follows:\n1. Initialize an empty stack.\n2. Create a hash map to store the matching pairs of brackets (e.g., `')': '('`). This allows for quick lookups.\n3. Iterate through each character of the input string.\n4. If the character is an opening bracket (`(`, `{`, `[`), push it onto the stack.\n5. If the character is a closing bracket (`)`, `}`, `]`), we check two conditions:\n   a. Is the stack empty? If so, we have a closing bracket with no corresponding opener, so the string is invalid.\n   b. Does the top element of the stack match the opening bracket for the current closing bracket? We pop from the stack and check. If they don't match, the string is invalid.\n6. After the loop finishes, if the stack is empty, it means every opening bracket was correctly matched and closed. If the stack is not empty, it means there are unclosed opening brackets.\n\nTherefore, the string is valid if and only if the stack is empty at the very end.",
    "dry_run": "Example: `s = \"([)]\"`\n1. `char = '('`. It's an opener. Push `'('` onto the stack. Stack: `['(']`.\n2. `char = '['`. It's an opener. Push `'['` onto the stack. Stack: `['(', '[']`.\n3. `char = ')'`. It's a closer. Stack is not empty. Pop from stack: `'['`. Does `'['` match the opener for `')'`? No. Return `False`.",
    "test_cases": "- An empty string (should be valid).\n- A valid simple string like `\"()[]{}\"`.\n- A valid nested string like `\"([{}])\"`.\n- An invalid string with wrong order like `\"([)]\"`.\n- An invalid string with unclosed brackets like `\"(((\"`.",
    "ia_solution": "class Solution:\n    def isValid(self, s: str) -> bool:\n        # The stack will store the opening brackets we encounter.\n        stack = []\n\n        # FORYOU!!: Explain why a stack is the ideal data structure here.\n        # Answer: Parentheses follow a Last-In, First-Out (LIFO) rule. The last bracket that was opened must be the first one to be closed. A stack naturally models this LIFO behavior, making it the perfect tool for matching pairs.\n        \n        # This hash map provides an O(1) lookup for matching brackets.\n        mapping = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n\n        for char in s:\n            # If the character is a closing bracket...\n            if char in mapping:\n                # If the stack is empty, we have a closing bracket with no opener. Invalid.\n                if not stack:\n                    return False\n                # Pop from the stack and check if it's the correct opening bracket.\n                top_element = stack.pop()\n                if mapping[char] != top_element:\n                    return False\n            else:\n                # If it's an opening bracket, push it onto the stack.\n                stack.append(char)\n        \n        # After the loop, the string is valid only if the stack is empty.\n        # A non-empty stack means there are unclosed opening brackets.\n        return not stack",
    "manual_solution": "class Solution:\n    def isValid(self, s: str) -> bool:\n        # The stack will store the opening brackets we encounter.\n        stack = []\n\n        # FORYOU!!: Explain why a stack is the ideal data structure here.\n        # Answer: Parentheses follow a Last-In, First-Out (LIFO) rule. The last bracket that was opened must be the first one to be closed. A stack naturally models this LIFO behavior, making it the perfect tool for matching pairs.\n        \n        # This hash map provides an O(1) lookup for matching brackets.\n        mapping = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n\n        for char in s:\n            # If the character is a closing bracket...\n            if char in mapping:\n                # Pop from the stack if it's not empty, otherwise use a dummy value.\n                top_element = stack.pop() if stack else '#'\n                \n                # Check if the popped element is the corresponding opening bracket.\n                if mapping[char] != top_element:\n                    return False\n            else:\n                # If it's an opening bracket, push it onto the stack.\n                stack.append(char)\n        \n        # After the loop, the string is valid only if the stack is empty.\n        # A non-empty stack means there are unclosed opening brackets.\n        return not stack"
  },
  {
    "title": "Merge Two Sorted Lists",
    "link": "https://leetcode.com/problems/merge-two-sorted-lists",
    "keywords": [
      "#LinkedList",
      "#Recursion",
      "#Iteration"
    ],
    "complexity": {
      "time": {
        "notation": "O(N + M)",
        "justification": "Where N and M are the lengths of the two lists. We must visit every node in both lists exactly once to build the merged list."
      },
      "space": {
        "notation": "O(1) for iterative, O(N + M) for recursive",
        "justification": "The iterative solution uses constant extra space for pointers. The recursive solution uses space on the call stack, which in the worst case can be proportional to the total number of nodes."
      }
    },
    "whiteboard": "The goal is to merge two sorted linked lists into a single sorted list. The most space-efficient method is iterative. We start by creating a `dummy` head node, which simplifies the code by providing a fixed entry point. A `current` pointer tracks the end of our newly forming list, initially pointing to `dummy`.\n\nWe then iterate as long as both input lists (`l1` and `l2`) have nodes. In each step, we compare the values of the heads of `l1` and `l2`. We append the smaller node to `current.next` and advance the pointer of the list from which we took the node. We then advance the `current` pointer to the new end of the list.\n\nOnce one of the lists is exhausted, the other may still contain nodes. Since that remaining list is already sorted, we can simply append it entirely to the end of our merged list. Finally, we return `dummy.next`, which is the true head of the merged list.\nThe recursive solution is also elegant but less space-efficient due to the call stack.",
    "dry_run": "Example: `l1 = [1,2,4]`, `l2 = [1,3,4]`\n1. `dummy = ListNode(0)`, `current = dummy`.\n2. `l1.val (1)` is not less than `l2.val (1)`. Let's say we pick `l2`.\n   - `current.next = l2`. `current` moves to `l2`. `l2` moves to `3`.\n   - List: `dummy -> 1`\n3. `l1.val (1) < l2.val (3)`. \n   - `current.next = l1`. `current` moves to `l1`. `l1` moves to `2`.\n   - List: `dummy -> 1 -> 1`\n4. `l1.val (2) < l2.val (3)`.\n   - `current.next = l1`. `current` moves to `l1`. `l1` moves to `4`.\n   - List: `dummy -> 1 -> 1 -> 2`\n5. `l1.val (4) > l2.val (3)`.\n   - `current.next = l2`. `current` moves to `l2`. `l2` moves to `4`.\n   - List: `dummy -> 1 -> 1 -> 2 -> 3`\n6. ... and so on until one list is empty. Then append the remainder. Final list: `[1,1,2,3,4,4]`.",
    "test_cases": "- One or both lists are empty.\n- Lists of different lengths.\n- Lists containing duplicate values.",
    "ia_solution": "class Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        # FORYOU!!: The iterative solution is often preferred in interviews as it uses O(1) space, avoiding potential stack overflow with very long lists.\n        # A dummy node simplifies edge cases like an empty result list.\n        dummy = ListNode(0)\n        current = dummy\n\n        # Traverse both lists until one is exhausted.\n        while l1 and l2:\n            # Compare the values and append the smaller node.\n            if l1.val < l2.val:\n                current.next = l1\n                l1 = l1.next\n            else:\n                current.next = l2\n                l2 = l2.next\n            # Move the current pointer to the new end of the merged list.\n            current = current.next\n\n        # Append the remaining part of the non-empty list.\n        current.next = l1 or l2\n\n        # The merged list starts at dummy.next.\n        return dummy.next\n",
    "manual_solution": "class Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        # FORYOU!!: This is a clean recursive solution. Be prepared to discuss its space complexity (O(N+M) on the call stack) and the iterative alternative.\n        \n        # Base case: if one list is empty, return the other.\n        if not l1: return l2\n        if not l2: return l1\n        \n        # Recursive step: Compare the heads of the lists.\n        if l1.val < l2.val:\n            # If l1's head is smaller, it becomes the head of the merged list.\n            # Its `next` pointer is the result of merging the rest of l1 and all of l2.\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            # Otherwise, l2's head is smaller or equal.\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2\n"
  },
  {
    "title": "Generate Parentheses",
    "link": "https://leetcode.com/problems/generate-parentheses",
    "keywords": [
      "#String",
      "#Backtracking",
      "#Recursion",
      "#DFS"
    ],
    "complexity": {
      "time": {
        "notation": "O(4^n / sqrt(n))",
        "justification": "The number of valid parenthesis combinations is given by the nth Catalan number, which is asymptotically bound by this complexity. Each valid combination of length 2n is generated."
      },
      "space": {
        "notation": "O(4^n / sqrt(n))",
        "justification": "The space is required to store the result. The recursion depth of the backtracking solution is at most 2n, so the call stack uses O(n) space."
      }
    },
    "whiteboard": "This is a classic backtracking problem. The core idea is to build the parenthesis string character by character, ensuring it remains valid at each step. A combination is valid if two conditions are always met:\n1. The number of open parentheses `(` never exceeds `n`.\n2. The number of closing parentheses `)` never exceeds the number of open parentheses.\n\nWe can implement this with a recursive function, say `backtrack(current_string, open_count, close_count)`. The base case is when the `current_string` length is `2 * n`. At this point, we've formed a complete, valid combination, so we add it to our results.\n\nIn the recursive step, we have two choices:\n1. Add an open parenthesis: If `open_count < n`, we can add a `(`. We then make a recursive call with the updated string and `open_count + 1`.\n2. Add a closing parenthesis: If `close_count < open_count`, we can add a `)`. We then make a recursive call with the updated string and `close_count + 1`.\nBy only making recursive calls when these conditions are met, we prune the search space and only generate valid combinations.",
    "dry_run": "Example: `n = 2`\n`backtrack(s, open, close)`\n1. `backtrack(\"\", 0, 0)`\n2.  -> Add '(': `open < 2`. Call `backtrack(\"(\", 1, 0)`\n3.    -> Add '(': `open < 2`. Call `backtrack(\"((`, 2, 0)`\n4.      -> Add ')': `close < open`. Call `backtrack(\"(()\", 2, 1)`\n5.        -> Add ')': `close < open`. Call `backtrack(\"(())\", 2, 2)`. Base case. Add \"(())\". Return.\n6.    -> Add ')': `close < open`. Call `backtrack(\"()\", 1, 1)`\n7.      -> Add '(': `open < 2`. Call `backtrack(\"()(\", 2, 1)`\n8.        -> Add ')': `close < open`. Call `backtrack(\"()()\", 2, 2)`. Base case. Add \"()()\". Return.\nFinal result: `[\"(())\", \"()()\"]`",
    "test_cases": "- n = 0 (should return [\"\"] or handle as per problem spec).\n- n = 1 (should return [\"()\"]).\n- A larger n like 3 or 4.",
    "ia_solution": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        # FORYOU!!: Backtracking is the standard, expected approach for this problem. Be ready to explain the constraints that guide the recursion.\n        res = []\n\n        def backtrack(current_string, open_count, close_count):\n            # Base case: when we have a complete combination of length 2*n\n            if len(current_string) == 2 * n:\n                res.append(current_string)\n                return\n\n            # Recursive step:\n            # Condition 1: We can add an opening bracket if we haven't used all n.\n            if open_count < n:\n                backtrack(current_string + '(', open_count + 1, close_count)\n\n            # Condition 2: We can add a closing bracket if it doesn't exceed the number of open brackets.\n            if close_count < open_count:\n                backtrack(current_string + ')', open_count, close_count + 1)\n\n        # Start the backtracking process\n        backtrack(\"\", 0, 0)\n        return res\n",
    "manual_solution": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        # FORYOU!!: This is a clever iterative (BFS-style) solution, but it can be harder to reason about and explain than the standard backtracking approach. It builds all strings layer by layer.\n        # Start with the initial state: 0 open, 0 closed, empty string.\n        bfs = [(0, 0, '')]\n        \n        # Loop 2*n times, as this is the final length of the strings.\n        for _ in range(n * 2):\n            # This is a list comprehension that builds the next layer of strings.\n            # It's dense: it tries to add '(' and ')' to all current strings and filters them based on the rules.\n            bfs = [(l + 1, r, s + '(') for l, r, s in bfs if l + 1 <= n] + \\\n                  [(l, r + 1, s + ')') for l, r, s in bfs if r < l] \n        \n        # After 2*n iterations, the bfs list contains all valid combinations.\n        return [s for l, r, s in bfs]\n"
  },
  {
    "title": "Merge k Sorted Lists",
    "link": "https://leetcode.com/problems/merge-k-sorted-lists",
    "keywords": [
      "#LinkedList",
      "#Heap",
      "#PriorityQueue",
      "#DivideAndConquer"
    ],
    "complexity": {
      "time": {
        "notation": "O(N log k)",
        "justification": "Where N is the total number of nodes and k is the number of lists. The main operations are on a min-heap. We insert k initial nodes (O(k log k)). Then, for each of the N nodes, we do one extract-min (O(log k)) and one insert (O(log k)). This leads to O(N log k)."
      },
      "space": {
        "notation": "O(k)",
        "justification": "The min-heap will store at most k elements (one from each list) at any given time."
      }
    },
    "whiteboard": "A brute-force approach, like collecting all nodes into an array and sorting it, would be O(N log N) in time and O(N) in space, which is suboptimal. A much better solution uses a **min-heap** (or priority queue).\n\nThe algorithm is as follows:\n1. Create a min-heap and a `dummy` head for the result list.\n2. Iterate through the input `lists`. For each non-empty list, push a tuple `(node.val, list_index, node)` onto the heap. We need `list_index` to break ties if values are equal, preventing errors with non-comparable Node objects.\n3. While the heap is not empty, pop the element with the smallest value. This will be the next node in our sorted list.\n4. Append this node to the result list.\n5. If this node has a `next` node in its original list, push that `next` node onto the heap.\n6. Repeat until the heap is empty.\n\nThis approach is efficient because the heap always gives us the absolute smallest node among all list heads in O(log k) time, and we only need to store `k` nodes in the heap.",
    "dry_run": "Example: `lists = [[1,4,5], [1,3,4], [2,6]]`\n1. `heap = []`. `dummy = ListNode(0)`.\n2. Push heads: `(1, 0, node1)`, `(1, 1, node1)`, `(2, 2, node2)`. Heap is now `[(1,0,node1), (1,1,node1), (2,2,node2)]` (order of 1s may vary).\n3. Pop `(1, 0, node1)`. Append it to result. Push its next node `(4, 0, node4)` to heap.\n   - Result: `dummy -> 1`. Heap: `[(1,1,node1), (2,2,node2), (4,0,node4)]`.\n4. Pop `(1, 1, node1)`. Append it. Push its next `(3, 1, node3)`.\n   - Result: `dummy -> 1 -> 1`. Heap: `[(2,2,node2), (3,1,node3), (4,0,node4)]`.\n5. Pop `(2, 2, node2)`. Append it. Push its next `(6, 2, node6)`.\n   - Result: `dummy -> 1 -> 1 -> 2`. Heap: `[(3,1,node3), (4,0,node4), (6,2,node6)]`.\n6. Continue until heap is empty. Final list: `[1,1,2,3,4,4,5,6]`.",
    "test_cases": "- An empty list of lists.\n- A list containing empty lists.\n- Lists of varying lengths.\n- A list with only one list.",
    "ia_solution": "import heapq\n\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        # FORYOU!!: This min-heap approach is the standard optimal solution. Be prepared to explain its time/space complexity and why it's better than the brute-force sort.\n        # The heap stores tuples of (value, index, node) to keep track of the smallest current node.\n        # The index is a tie-breaker to prevent comparison errors on ListNode objects.\n        min_heap = []\n        for i, l in enumerate(lists):\n            if l:\n                heapq.heappush(min_heap, (l.val, i, l))\n\n        # Dummy head to simplify list construction.\n        dummy = ListNode(0)\n        current = dummy\n\n        # While there are still nodes to process...\n        while min_heap:\n            # Pop the smallest node from the heap.\n            val, i, node = heapq.heappop(min_heap)\n\n            # Append it to our result list.\n            current.next = node\n            current = current.next\n\n            # If the popped node has a next element, push it to the heap.\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, i, node.next))\n\n        return dummy.next\n",
    "manual_solution": "class Solution:\n    def mergeKLists(self, lists):\n        # FORYOU!!: This brute-force solution is easy to understand but very inefficient. An interviewer would expect you to identify the performance issues (O(N) space and O(N log N) time) and propose the min-heap solution.\n        q = []\n        # Step 1: Traverse all lists and dump every single node into an array `q`.\n        # This uses O(N) extra space, where N is the total number of nodes.\n        for i in range(len(lists)):\n            node = lists[i]\n            while node:\n                q.append(node)\n                node = node.next\n        \n        # Dummy node to start the new list.\n        root = cur = ListNode(0)\n        \n        # Step 2: Sort the entire array of nodes. This is the bottleneck, taking O(N log N) time.\n        for h in sorted(q, key = lambda x: x.val):\n            # Step 3: Re-link the sorted nodes into a new list.\n            cur.next = h\n            cur = h\n            \n        # Step 4: Important - sever the link from the last node to its original next node.\n        if q: \n            cur.next = None\n            \n        return root.next\n"
  },
  {
    "title": "Swap Nodes in Pairs",
    "link": "https://leetcode.com/problems/swap-nodes-in-pairs",
    "keywords": [
      "#LinkedList",
      "#Recursion",
      "#Iteration"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We need to visit each node in the list once to perform the swaps."
      },
      "space": {
        "notation": "O(1) for iterative, O(N) for recursive",
        "justification": "The iterative solution uses constant extra space for pointers. The recursive solution's space complexity is determined by the depth of the recursion stack, which can be up to N/2."
      }
    },
    "whiteboard": "The task is to swap every two adjacent nodes in a linked list. For example, `1->2->3->4` should become `2->1->4->3`. An iterative approach is often preferred for its O(1) space complexity.\n\nWe use a `dummy` node pointing to the head to handle the edge case of swapping the first two nodes. We also need a `prev` pointer, initialized to the `dummy` node, to keep track of the node *before* the pair we are currently swapping. This allows us to re-link the list correctly after a swap.\n\nThe logic inside the loop is as follows (while `prev.next` and `prev.next.next` exist):\n1. Identify the two nodes to be swapped: `first = prev.next` and `second = prev.next.next`.\n2. Perform the swap:\n   - `first.next` should point to `second.next` (linking the first node to the rest of the list).\n   - `second.next` should point back to `first`.\n   - `prev.next` should now point to `second` (linking the previous part of the list to the new head of the pair).\n3. Move `prev` forward two steps (`prev = first`) to prepare for the next pair.\n\nFinally, return `dummy.next`.",
    "dry_run": "Example: `head = [1,2,3,4]`\n1. `dummy -> 1 -> 2 -> 3 -> 4`. `prev = dummy`.\n2. **Iteration 1:**\n   - `first = 1`, `second = 2`.\n   - `first.next` becomes `3` (`second.next`).\n   - `second.next` becomes `1` (`first`).\n   - `prev.next` (dummy's next) becomes `2` (`second`).\n   - List is now `dummy -> 2 -> 1 -> 3 -> 4`.\n   - Move `prev` to `1`.\n3. **Iteration 2:**\n   - `prev` is `1`. `first = 3`, `second = 4`.\n   - `first.next` becomes `None` (`second.next`).\n   - `second.next` becomes `3` (`first`).\n   - `prev.next` (node 1's next) becomes `4` (`second`).\n   - List is now `dummy -> 2 -> 1 -> 4 -> 3`.\n   - Move `prev` to `3`.\n4. Loop terminates as `prev.next.next` is null. Return `dummy.next`.",
    "test_cases": "- An empty list.\n- A list with one node.\n- A list with an even number of nodes.\n- A list with an odd number of nodes.",
    "ia_solution": "class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # FORYOU!!: The iterative approach is great for interviews due to its O(1) space complexity.\n        dummy = ListNode(0, head)\n        prev = dummy\n\n        # We need at least two nodes ahead of prev to perform a swap.\n        while prev.next and prev.next.next:\n            # Identify the two nodes to swap.\n            first = prev.next\n            second = prev.next.next\n\n            # Perform the swap by re-wiring the 'next' pointers.\n            first.next = second.next\n            second.next = first\n            prev.next = second\n\n            # Move the prev pointer two steps forward for the next pair.\n            prev = first\n            \n        return dummy.next\n",
    "manual_solution": "class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # FORYOU!!: This recursive solution is elegant and concise. A good follow-up question would be to ask you to implement the iterative version.\n        \n        # Base Case: If there are less than two nodes, no swap is possible.\n        if not head or not head.next: \n            return head\n        \n        # Nodes to be swapped in the current step.\n        first = head\n        second = head.next\n        \n        # The first node's 'next' will point to the result of swapping the rest of the list.\n        # This is the recursive call on the subproblem.\n        first.next = self.swapPairs(second.next)\n        \n        # The second node's 'next' points back to the first node, completing the swap.\n        second.next = first\n        \n        # The new head of this swapped pair is the original second node.\n        return second\n"
  },
  {
    "title": "Reverse Nodes in k-Group",
    "link": "https://leetcode.com/problems/reverse-nodes-in-k-group",
    "keywords": [
      "#LinkedList",
      "#Recursion",
      "#Iteration"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "Although there are nested loops, each node is processed a constant number of times. We traverse to find the k-group, and then we traverse it again to reverse it. This results in a linear time complexity overall."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The optimal iterative solution uses a constant amount of extra space for pointers, regardless of the list size or k."
      }
    },
    "whiteboard": "This is a challenging linked list problem. The goal is to reverse the list in chunks of size `k`. If a final group has fewer than `k` nodes, it should remain unchanged.\n\nThe iterative approach is robust. We use a `dummy` node to simplify linking. We also need a pointer, `group_prev`, which marks the end of the *previous* reversed group (or the dummy node initially). This is the node we will connect the *new* reversed group to.\n\nThe main loop works as follows:\n1.  From `group_prev`, find the start of the current group (`kth` node). We need to traverse `k` nodes to find the end of the group. If we can't find `k` nodes, we're done, and we link `group_prev` to the start of this final, partial group and break.\n2.  If a full group of `k` is found, we isolate it. Let `group_next` be the node after the `kth` node. We will need this to connect the reversed group back to the rest of the list.\n3.  We reverse the group of `k` nodes. This is a standard list reversal sub-problem. The `head` of this reversed group will be the original `kth` node.\n4.  **Re-link everything**: `group_prev.next` now points to the new head of the reversed group (the original `kth` node). The tail of the reversed group (the original start of the group) now points to `group_next`.\n5.  **Update for the next iteration**: The new `group_prev` is now the tail of the group we just reversed.",
    "dry_run": "Example: `head = [1,2,3,4,5]`, `k = 2`\n1. `dummy -> 1...`, `group_prev = dummy`.\n2. **Group 1 (1,2):**\n   - Find `kth` node (node 2). It exists. `group_next` is node 3.\n   - Reverse `1 -> 2` to `2 -> 1`.\n   - Link `dummy.next` to `2`. Link `1.next` to `3` (`group_next`).\n   - List: `dummy -> 2 -> 1 -> 3 -> 4 -> 5`.\n   - Update `group_prev` to be node 1.\n3. **Group 2 (3,4):**\n   - From `group_prev` (node 1), find `kth` node (node 4). It exists. `group_next` is node 5.\n   - Reverse `3 -> 4` to `4 -> 3`.\n   - Link `group_prev.next` (1's next) to `4`. Link `3.next` to `5` (`group_next`).\n   - List: `dummy -> 2 -> 1 -> 4 -> 3 -> 5`.\n   - Update `group_prev` to be node 3.\n4. **Group 3 (5):**\n   - From `group_prev` (node 3), try to find 2 nodes. We only find one. Loop terminates.\n5. Return `dummy.next`.",
    "test_cases": "- `k = 1` (list should be unchanged).\n- List length is a multiple of `k`.\n- List length is not a multiple of `k`.\n- `k` is greater than the list length.",
    "ia_solution": "class Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        # FORYOU!!: This problem tests mastery of linked list manipulation. Explaining the roles of group_prev, group_next, and the standard reversal logic is key.\n        if not head or k == 1:\n            return head\n\n        dummy = ListNode(0, head)\n        group_prev = dummy\n\n        while True:\n            # 1. Find the kth node of the current group\n            kth = self.get_kth(group_prev, k)\n            if not kth:\n                break\n\n            group_next = kth.next\n\n            # 2. Reverse the group\n            # The group to reverse starts at group_prev.next\n            prev, curr = group_next, group_prev.next\n            while curr != group_next:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n            \n            # 3. Re-link the reversed group\n            tmp = group_prev.next\n            group_prev.next = kth\n            group_prev = tmp\n\n        return dummy.next\n\n    def get_kth(self, curr, k):\n        # Helper to find the kth node from a given starting node\n        while curr and k > 0:\n            curr = curr.next\n            k -= 1\n        return curr\n",
    "manual_solution": "class Solution:\n    def reverseKGroup(self, head, k):\n        # FORYOU!!: This solution is functional but can be slightly hard to follow. The IA solution separates the logic more cleanly, e.g., by using a helper to find the kth node.\n        dummy = last = ListNode(0)\n        cur = head\n        while cur:\n            # `first` marks the start of the potential group\n            first, cnt = cur, 1\n            # Find the end of the group\n            while cnt < k and cur:\n                cur, cnt = cur.next, cnt + 1\n            \n            # If we found a full group of size k\n            if cnt == k and cur:\n                # `cur` is now the end of the group. Store the start of the *next* group.\n                next_group_start = cur.next\n                \n                # Standard list reversal on the group\n                prev = None\n                node_to_reverse = first\n                for _ in range(k):\n                    tmp_next = node_to_reverse.next\n                    node_to_reverse.next = prev\n                    prev = node_to_reverse\n                    node_to_reverse = tmp_next\n                \n                # Re-link the reversed group. `last` points to the tail of the previous group.\n                last.next = prev # prev is the new head of the reversed group\n                last = first # first is the new tail of the reversed group\n                \n                # Move `cur` to the start of the next group\n                cur = next_group_start\n            else:\n                # If the remaining part is not a full group, link it and we're done.\n                last.next = first\n                break # Break the loop\n        return dummy.next\n"
  },
  {
    "title": "Remove Duplicates from Sorted Array",
    "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#InPlace"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We iterate through the array with a single pass. Both pointers, `i` and `j`, traverse the array at most once."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The operation is performed in-place, modifying the array directly without using any extra space proportional to the input size."
      }
    },
    "whiteboard": "The problem requires us to remove duplicates from a sorted array in-place, meaning we cannot use an extra array. The key is to use a **two-pointer** approach.\n\nWe use a 'slow' pointer, let's call it `i` or `write_ptr`, which points to the position where the next unique element should be written. We use a 'fast' pointer, `j` or `read_ptr`, to iterate through the array.\n\nThe algorithm is:\n1. Initialize `i` to `1` (since the first element `nums[0]` is always unique by itself).\n2. Iterate with `j` from `1` to the end of the array.\n3. At each step, compare `nums[j]` with the previous element `nums[j-1]`.\n4. If `nums[j]` is **different** from `nums[j-1]`, it means we've found a new unique element.\n5. We then copy this unique element to the position of our slow pointer: `nums[i] = nums[j]`, and then increment `i`.\n6. If `nums[j]` is the same as `nums[j-1]`, we do nothing but continue incrementing `j`, effectively skipping the duplicate.\n\nAfter the loop finishes, `i` will be the length of the new array with unique elements. The first `i` elements of the original array will be the unique, sorted values.",
    "dry_run": "Example: `nums = [0,0,1,1,1,2,2]`\n1. Initialize `i = 1`.\n2. `j = 1`. `nums[1] (0)` is equal to `nums[0] (0)`. Do nothing.\n3. `j = 2`. `nums[2] (1)` is not equal to `nums[1] (0)`. It's a unique element.\n   - `nums[i] = nums[j]` => `nums[1] = 1`.\n   - `i++`. `i` is now `2`.\n   - Array is now `[0,1,1,1,1,2,2]`.\n4. `j = 3`. `nums[3] (1)` is equal to `nums[2] (1)`. Do nothing.\n5. `j = 4`. `nums[4] (1)` is equal to `nums[3] (1)`. Do nothing.\n6. `j = 5`. `nums[5] (2)` is not equal to `nums[4] (1)`. It's unique.\n   - `nums[i] = nums[j]` => `nums[2] = 2`.\n   - `i++`. `i` is now `3`.\n   - Array is now `[0,1,2,1,1,2,2]`.\n7. `j = 6`. `nums[6] (2)` is equal to `nums[5] (2)`. Do nothing.\n8. Loop ends. Return `i`, which is `3`. The first 3 elements are `[0,1,2]`.",
    "test_cases": "- An empty array.\n- An array with all unique elements.\n- An array with all duplicate elements.\n- An array with duplicates at the beginning and end.",
    "ia_solution": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # FORYOU!!: This two-pointer approach is the standard, optimal O(N) time and O(1) space solution. It's exactly what interviewers look for.\n        # If the list is empty, there are no elements.\n        if not nums:\n            return 0\n        \n        # `write_ptr` is the slow pointer. It indicates the position for the next unique element.\n        write_ptr = 1\n        \n        # `read_ptr` is the fast pointer that iterates through the array.\n        for read_ptr in range(1, len(nums)):\n            # If the current element is different from the previous one, it's unique.\n            if nums[read_ptr] != nums[read_ptr - 1]:\n                # Place the unique element at the write_ptr position.\n                nums[write_ptr] = nums[read_ptr]\n                # Move the write pointer to the next position.\n                write_ptr += 1\n        \n        # `write_ptr` now represents the new length of the array.\n        return write_ptr\n",
    "manual_solution": "class Solution:\n    def removeDuplicates(self, nums):\n        # FORYOU!!: This solution is clever but highly inefficient. Using `pop()` inside a loop on a list is an O(N^2) operation because each pop can cause a shift of all subsequent elements. An interviewer will immediately ask about the time complexity of this and expect the two-pointer solution instead.\n        n = len(nums)\n        # Iterate backwards to avoid index shifting issues when popping.\n        # The list comprehension builds a temporary list of popped elements, but its main purpose is the side effect of popping from `nums`.\n        removed_count = len([nums.pop(i) for i in range(n - 1, 0, -1) if nums[i] == nums[i - 1]])\n        # The new length is the original length minus the count of removed items.\n        return n - removed_count\n"
  },
  {
    "title": "Remove Element",
    "link": "https://leetcode.com/problems/remove-element",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#InPlace"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We iterate through the array once. Each element is read, and some are written, but each position is processed a constant number of times."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The operation is done in-place, modifying the input array without allocating extra space proportional to its size."
      }
    },
    "whiteboard": "This problem is very similar to 'Remove Duplicates from Sorted Array' and is best solved with a two-pointer technique for an in-place modification.\n\nThe goal is to remove all instances of a given value `val` and return the new length of the array. The order of the elements that are kept can be changed.\n\nWe use a 'slow' pointer, `i` or `write_ptr`, to keep track of the position where the next element *not equal to `val`* should be placed. We use a 'fast' pointer (implicit in the `for` loop) to iterate through all elements of the array.\n\nThe algorithm is:\n1. Initialize `i = 0`.\n2. Iterate through each `num` in `nums`.\n3. If `num` is **not equal to `val`**, it's an element we want to keep.\n4. We place this element at the `i`-th position: `nums[i] = num`.\n5. We then increment `i` to move to the next available slot.\n6. If `num` is equal to `val`, we simply do nothing, effectively overwriting it later or leaving it at the end of the array.\n\nAfter the loop, `i` will be the count of elements that are not `val`, which is the new length of the modified array. The first `i` elements of `nums` will be the desired result.",
    "dry_run": "Example: `nums = [3,2,2,3]`, `val = 3`\n1. Initialize `i = 0`.\n2. Loop 1: `num = 3`. This is equal to `val`. Do nothing.\n3. Loop 2: `num = 2`. This is not `val`.\n   - `nums[i] = num` => `nums[0] = 2`.\n   - `i++`. `i` is now `1`.\n   - Array is `[2,2,2,3]`.\n4. Loop 3: `num = 2`. This is not `val`.\n   - `nums[i] = num` => `nums[1] = 2`.\n   - `i++`. `i` is now `2`.\n   - Array is `[2,2,2,3]`.\n5. Loop 4: `num = 3`. This is equal to `val`. Do nothing.\n6. Loop ends. Return `i`, which is `2`. The first two elements are `[2,2]`.",
    "test_cases": "- `val` is not in the array.\n- All elements in the array are `val`.\n- The array is empty.\n- `val` is at the beginning or end of the array.",
    "ia_solution": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        # FORYOU!!: This two-pointer solution is the standard and most efficient. There is another two-pointer optimization possible if the order of elements can be changed (which it can here). When you find an element to remove at `nums[i]`, you can swap it with the last element `nums[n-1]` and decrement `n`. This can be faster if the elements to remove are rare.\n        \n        # `write_ptr` keeps track of the position to place the next valid element.\n        write_ptr = 0\n        \n        # Iterate through the array with a read pointer.\n        for read_ptr in range(len(nums)):\n            # If the current element is one we want to keep...\n            if nums[read_ptr] != val:\n                # ...move it to the write position.\n                nums[write_ptr] = nums[read_ptr]\n                # and advance the write position.\n                write_ptr += 1\n        \n        # The final position of the write pointer is the new length.\n        return write_ptr\n",
    "manual_solution": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        # FORYOU!!: This is the correct, optimal two-pointer solution. It's exactly what an interviewer would be looking for. Great job!\n        \n        # `i` acts as the slow/write pointer.\n        i = 0\n        # The loop iterates through each number, acting as the fast/read pointer.\n        for num in nums:\n            # If the number is not the value to be removed...\n            if num != val:\n                # ...place it at the current slow pointer position.\n                nums[i] = num\n                # And advance the slow pointer.\n                i += 1\n        # The final value of `i` is the count of elements kept, which is the new length.\n        return i\n"
  },
  {
    "title": "Implement strStr()",
    "link": "https://leetcode.com/problems/implement-strstr",
    "keywords": [
      "#String",
      "#TwoPointers",
      "#SlidingWindow"
    ],
    "complexity": {
      "time": {
        "notation": "O((N-M+1) * M)",
        "justification": "Where N is the length of the haystack and M is the length of the needle. This is for the brute-force sliding window approach. In the worst case (e.g., haystack='aaaaab', needle='aab'), we compare the needle of length M at each of the N-M+1 possible starting positions."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The simple sliding window approach uses constant extra space."
      }
    },
    "whiteboard": "The problem asks us to find the first occurrence of a `needle` string within a `haystack` string. While Python has a built-in `.find()` method, an interview requires you to implement the logic yourself. A common approach is a **brute-force sliding window**.\n\nThe algorithm works as follows:\n1. Handle edge cases: If `needle` is empty, return 0. If `needle` is longer than `haystack`, it can't be found, so return -1.\n2. We iterate through the `haystack` with a pointer `i`, from the beginning up to the last possible starting position for the `needle`. The last possible position is `len(haystack) - len(needle)`.\n3. For each starting position `i`, we check if the substring of `haystack` of length `len(needle)` starting at `i` is equal to the `needle`.\n4. In other words, we check if `haystack[i : i + len(needle)] == needle`.\n5. If we find a match, we immediately return the starting index `i`.\n6. If the loop completes without finding a match, we return -1.\n\nFor advanced interviews, one might discuss more optimal algorithms like Knuth-Morris-Pratt (KMP), which has O(N+M) time complexity, but the sliding window is a solid baseline.",
    "dry_run": "Example: `haystack = \"hello\"`, `needle = \"ll\"`\n1. `n = 5`, `m = 2`. We will loop `i` from 0 to 3.\n2. `i = 0`: `haystack[0:2]` is `\"he\"`. No match.\n3. `i = 1`: `haystack[1:3]` is `\"el\"`. No match.\n4. `i = 2`: `haystack[2:4]` is `\"ll\"`. Match! Return `i`, which is 2.",
    "test_cases": "- Needle is an empty string.\n- Haystack is an empty string.\n- Needle is not found in haystack.\n- Needle appears at the beginning or end of haystack.\n- Needle is longer than haystack.",
    "ia_solution": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        # FORYOU!!: While using `.find()` is clever for a contest, in an interview, you must implement the algorithm yourself. This sliding window approach is the standard expectation.\n        \n        # Edge case: empty needle\n        if not needle:\n            return 0\n        \n        n, m = len(haystack), len(needle)\n        \n        # The loop runs up to the last possible starting point for the needle.\n        for i in range(n - m + 1):\n            # Check if the substring of haystack matches the needle.\n            if haystack[i:i+m] == needle:\n                return i\n        \n        # If the loop completes without a match.\n        return -1\n",
    "manual_solution": "class Solution:\n    def strStr(self, haystack, needle):\n        # FORYOU!!: This solution is correct and passes, but it simply calls a built-in library function. An interviewer will almost certainly say \"Great, now can you implement it without using `.find()`?\" The purpose of the question is to test your understanding of string manipulation algorithms.\n        return haystack.find(needle)\n"
  },
  {
    "title": "Divide Two Integers",
    "link": "https://leetcode.com/problems/divide-two-integers",
    "keywords": [
      "#Math",
      "#BitManipulation",
      "#BinarySearch"
    ],
    "complexity": {
      "time": {
        "notation": "O(log N)",
        "justification": "Where N is the value of the dividend. In each step of the outer loop, we subtract powers of 2 of the divisor. The inner loop doubles the temporary value (`temp <<= 1`), which means we are essentially finding the largest power of 2 that fits, similar to a binary search on the quotient. The number of such steps is logarithmic."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The algorithm uses a fixed number of variables to store state, resulting in constant space complexity."
      }
    },
    "whiteboard": "This problem requires dividing two integers without using multiplication, division, or the modulo operator. The core idea is to use repeated subtraction. A naive approach of subtracting the `divisor` one by one would be too slow (O(N)), so we need to speed it up.\n\nWe can use an approach similar to binary search by subtracting exponentially increasing multiples of the `divisor`. This is efficiently done using bit shifts (`<< 1` is equivalent to multiplying by 2).\n\nThe algorithm is:\n1. Handle the sign. Determine if the result should be positive or negative and then work with the absolute values of the dividend and divisor.\n2. Use an outer loop that continues as long as the `dividend` is greater than or equal to the `divisor`.\n3. Inside, use an inner loop to find the largest multiple of the `divisor` of the form `divisor * 2^i` that is still less than or equal to the current `dividend`.\n4. We start with `temp = divisor` and `multiple = 1`. In the inner loop, we keep doubling both (`temp <<= 1`, `multiple <<= 1`) as long as `temp` fits into the `dividend`.\n5. Once the inner loop finishes, we subtract the largest `temp` found from the `dividend` and add the corresponding `multiple` to our result.\n6. Repeat the outer loop with the new, smaller dividend.\n7. Finally, apply the correct sign and handle the integer overflow edge case `(-2^31 / -1)`.",
    "dry_run": "Example: `dividend = 10`, `divisor = 3`\n1. `dividend = 10`, `divisor = 3`, `res = 0`.\n2. **Outer loop 1:** `10 >= 3`.\n   - `temp = 3`, `multiple = 1`.\n   - Inner loop: `10 >= 3`. `10 >= 6`. `10 < 12`. Inner loop stops at `temp=6`, `multiple=2`.\n   - `dividend -= 6` => `dividend = 4`.\n   - `res += 2` => `res = 2`.\n3. **Outer loop 2:** `4 >= 3`.\n   - `temp = 3`, `multiple = 1`.\n   - Inner loop: `4 >= 3`. `4 < 6`. Inner loop stops at `temp=3`, `multiple=1`.\n   - `dividend -= 3` => `dividend = 1`.\n   - `res += 1` => `res = 3`.\n4. **Outer loop 3:** `1 < 3`. Loop terminates.\n5. Return `res`, which is `3`.",
    "test_cases": "- Dividing by 1 or -1.\n- The edge case `dividend = -2^31, divisor = -1` which causes overflow.\n- Dividend is zero.\n- Handling negative numbers correctly.",
    "ia_solution": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # FORYOU!!: This problem tests bit manipulation and handling edge cases. Explaining how `<<=` is used to find powers-of-2 multiples of the divisor is the key part of the explanation.\n        \n        # Handle the integer overflow edge case.\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        \n        # Determine the sign of the result.\n        is_negative = (dividend < 0) != (divisor < 0)\n        \n        # Work with absolute values.\n        dividend, divisor = abs(dividend), abs(divisor)\n        quotient = 0\n        \n        # Outer loop: subtract multiples until dividend is too small.\n        while dividend >= divisor:\n            # Inner loop: find the largest power of 2 multiple to subtract.\n            temp_divisor, multiple = divisor, 1\n            while dividend >= (temp_divisor << 1):\n                temp_divisor <<= 1\n                multiple <<= 1\n            \n            # Subtract the found multiple.\n            dividend -= temp_divisor\n            quotient += multiple\n            \n        # Apply the sign to the result.\n        return -quotient if is_negative else quotient\n",
    "manual_solution": "class Solution:\n    def divide(self, dividend, divisor):\n        # FORYOU!!: This is the correct and optimal bit manipulation approach. The variable names `temp` and `i` are a bit generic but the logic is sound. `positive` is a good way to track the sign.\n        \n        # Determine the sign.\n        positive = (dividend < 0) is (divisor < 0)\n        dividend, divisor = abs(dividend), abs(divisor)\n        res = 0\n        \n        # Main loop for subtraction.\n        while dividend >= divisor:\n            # `temp` is the divisor multiple we are trying to subtract.\n            # `i` is the corresponding quotient part (a power of 2).\n            temp, i = divisor, 1\n            # Double `temp` and `i` as long as `temp` fits into the dividend.\n            while dividend >= temp:\n                dividend -= temp\n                res += i\n                i <<= 1\n                temp <<= 1\n        \n        # Apply the sign.\n        if not positive:\n            res = -res\n        \n        # Handle the 32-bit integer limits.\n        return min(max(-2**31, res), 2**31 - 1)\n"
  },
  {
    "title": "Substring with Concatenation of All Words",
    "link": "https://leetcode.com/problems/substring-with-concatenation-of-all-words",
    "keywords": [
      "#String",
      "#HashTable",
      "#SlidingWindow"
    ],
    "complexity": {
      "time": {
        "notation": "O((N - L*M) * M)",
        "justification": "Where N is len(s), M is len(words), and L is len(words[0]). The outer loop runs N - L*M times. Inside, we have a loop that runs M times, and each substring operation takes L time. A more optimized sliding window is O(N*L)."
      },
      "space": {
        "notation": "O(M*L)",
        "justification": "We need space for the hash map to store the word counts, which holds M words of length L."
      }
    },
    "whiteboard": "This is a complex string problem best solved with a **sliding window** and **hash maps**. The goal is to find starting indices of substrings in `s` that are an exact concatenation of all words in `words`.\n\nFirst, we preprocess: create a frequency map (`word_counts`) of the words in the `words` list. This tells us what a valid window should contain. We also calculate `word_len` and the total `substring_len`.\n\nThe core idea is that we don't need to check every single character as a starting point. A valid substring must start at an index `i` such that `i % word_len` is constant. Therefore, we only need to run our sliding window algorithm `word_len` times, once for each possible starting offset (`for i in range(word_len)`).\n\nFor each offset, we use a standard sliding window approach:\n1. Maintain a window of size `substring_len` and a frequency map for the words seen within it (`window_counts`).\n2. As the window slides, update `window_counts` by adding the new word and removing the word that falls off.\n3. At each step, compare `window_counts` with the target `word_counts`. If they match, we've found a valid concatenation, so we record the starting index of the window.",
    "dry_run": "Example: `s = \"barfoothefoobarman\"`, `words = [\"foo\",\"bar\"]`\n1. `word_len = 3`, `num_words = 2`, `total_len = 6`.\n2. `word_counts = {\"foo\": 1, \"bar\": 1}`.\n3. **Main loop `i` from 0 to `len(s) - 6`**: `i = 0`.\n   - Check substring `s[0:6]` which is `\"barfoo\"`.\n   - Create a frequency map for this substring: `seen = {\"bar\": 1, \"foo\": 1}`.\n   - `seen` matches `word_counts`. Add `0` to results.\n4. `i = 1`: `s[1:7]` is `\"arfoot\"`. `seen = {\"arf\":1, \"oot\":1}`. No match.\n5. ...\n6. `i = 9`: `s[9:15]` is `\"foobar\"`. `seen = {\"foo\": 1, \"bar\": 1}`. Match. Add `9` to results.\n7. Final result: `[0, 9]`.",
    "test_cases": "- `words` list is empty.\n- Words with duplicate values.\n- Overlapping valid substrings.\n- `s` is shorter than the total concatenation length.",
    "ia_solution": "from collections import Counter\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        # FORYOU!!: The key to optimizing this is realizing you only need to run the sliding window `word_len` times, one for each starting offset. This avoids redundant checks.\n        if not s or not words:\n            return []\n\n        word_counts = Counter(words)\n        word_len = len(words[0])\n        num_words = len(words)\n        substring_len = word_len * num_words\n        res = []\n\n        # This outer loop handles the different start offsets.\n        for i in range(word_len):\n            left = i\n            window_counts = Counter()\n            words_in_window = 0\n            # Sliding window for this specific offset.\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word in word_counts:\n                    window_counts[word] += 1\n                    words_in_window += 1\n                    # If we have too many of one word, shrink window from the left.\n                    while window_counts[word] > word_counts[word]:\n                        left_word = s[left:left + word_len]\n                        window_counts[left_word] -= 1\n                        words_in_window -= 1\n                        left += word_len\n                    \n                    # If the window has the right number of words, it's a match.\n                    if words_in_window == num_words:\n                        res.append(left)\n                else:\n                    # If word is not in our dictionary, reset the window.\n                    window_counts.clear()\n                    words_in_window = 0\n                    left = j + word_len\n        return res\n",
    "manual_solution": "import collections\nclass Solution:\n    def findSubstring(self, s, words):\n        # FORYOU!!: This solution is a correct brute-force check. It works but is inefficient. For each possible start index `i`, it rebuilds a new hash map and re-checks the substring. The `ia_solution` uses a true sliding window to avoid this repeated work.\n        if not s or not words: return []\n        \n        # Pre-calculate counts and lengths.\n        cnt = collections.Counter(words)\n        l_words_total = len(words[0]) * len(words)\n        l_word = len(words[0])\n        cnt_words = len(words)\n        res = []\n        \n        # Iterate through every possible starting character.\n        for i in range(len(s) - l_words_total + 1):\n            # For each start, create a fresh copy of the word counts.\n            cur = dict(cnt)\n            j = i\n            # Check the next `cnt_words` blocks.\n            for _ in range(cnt_words):\n                w = s[j:j + l_word]\n                if w in cur:\n                    # Decrement the count for the seen word.\n                    if cur[w] == 1: \n                        cur.pop(w)\n                    else: \n                        cur[w] -= 1\n                else:\n                    # If word is not expected, this window is invalid.\n                    break\n                j += l_word\n            \n            # If the `cur` dictionary is empty, all words were found.\n            if not cur:\n                res.append(i)\n        return res\n"
  },
  {
    "title": "Next Permutation",
    "link": "https://leetcode.com/problems/next-permutation",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#InPlace"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "The algorithm involves at most two scans of the array from right to left to find the pivot and the swap element. The final reversal (or sort of the suffix) takes O(N) time. This results in a linear time complexity overall."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The permutation is generated in-place, modifying the input array directly without using extra space proportional to the input size."
      }
    },
    "whiteboard": "The problem asks to find the next lexicographically greater permutation of a sequence of numbers. This can be solved with a specific, elegant algorithm:\n\n1.  **Find the Pivot**: Scan the array from right to left. Find the first element `nums[i]` that is smaller than the element to its right (`nums[i+1]`). This `nums[i]` is our 'pivot'. It's the first element from the right that breaks a descending trend. If no such element is found, the entire array is in descending order (like `[3,2,1]`), which is the last permutation. In this case, we simply reverse the whole array to get the smallest permutation (`[1,2,3]`).\n\n2.  **Find the Swap Element**: If a pivot `nums[i]` is found, scan again from right to left. Find the first element `nums[j]` that is greater than the pivot `nums[i]`. This is the smallest element in the suffix that is still larger than the pivot.\n\n3.  **Swap**: Swap the pivot `nums[i]` with the swap element `nums[j]`.\n\n4.  **Reverse the Suffix**: After the swap, the suffix of the array starting from `i+1` is still in descending order. To get the smallest possible permutation with the new prefix, we must reverse this suffix to put it in ascending order.\n",
    "dry_run": "Example: `nums = [1, 3, 5, 4, 2]`\n1.  **Find Pivot**: \n    - `2 < 4` (no). `4 < 5` (no). `5 > 3` (yes!). The pivot is `nums[1]`, which is `3`.\n2.  **Find Swap Element**: \n    - Scan from right: `2 > 3` (no). `4 > 3` (yes!). The swap element is `nums[3]`, which is `4`.\n3.  **Swap**: Swap `nums[1]` and `nums[3]`.\n    - Array becomes `[1, 4, 5, 3, 2]`.\n4.  **Reverse Suffix**: Reverse the part after the pivot index (1). Reverse `[5, 3, 2]`.\n    - The suffix becomes `[2, 3, 5]`.\n    - Final array: `[1, 4, 2, 3, 5]`.",
    "test_cases": "- An array that is the last permutation (e.g., `[3,2,1]`).\n- An array that is the first permutation (e.g., `[1,2,3]`).\n- An array with duplicate numbers.\n- An array with two elements.",
    "ia_solution": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        # FORYOU!!: This is a classic algorithm. Being able to walk through the 4 steps (find pivot, find swap, swap, reverse suffix) is crucial.\n        n = len(nums)\n        # Step 1: Find the pivot (the first element from the right that is smaller than its right neighbor).\n        pivot = -1\n        for i in range(n - 2, -1, -1):\n            if nums[i] < nums[i+1]:\n                pivot = i\n                break\n\n        # If no pivot is found, the array is the last permutation. Reverse it.\n        if pivot == -1:\n            nums.reverse()\n            return\n        \n        # Step 2: Find the element to swap with the pivot (the smallest element in the suffix > pivot).\n        for i in range(n - 1, pivot, -1):\n            if nums[i] > nums[pivot]:\n                # Step 3: Swap.\n                nums[i], nums[pivot] = nums[pivot], nums[i]\n                break\n        \n        # Step 4: Reverse the suffix after the pivot to make it the smallest possible.\n        left, right = pivot + 1, n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n",
    "manual_solution": "class Solution:\n    def nextPermutation(self, nums):\n        # FORYOU!!: This solution's logic is a bit hard to follow. It combines finding the pivot and the swap element in nested loops, and uses `sorted()` which is less efficient (O(k log k)) than a simple reversal (O(k)) for the suffix. The standard 4-step algorithm is much clearer.\n        perm_found, l = False, len(nums) - 2\n        # `l` is the pivot search pointer, moving from right to left.\n        while 0 <= l:\n            r = len(nums) - 1\n            # `r` searches from the right for an element greater than the pivot `nums[l]`.\n            while l < r and nums[r] <= nums[l]: \n                r -= 1\n            \n            # If `r` didn't find anything greater than `l`, move `l` to the left.\n            if r <= l: \n                l -= 1\n            else:\n                # A valid pivot `l` and swap `r` were found.\n                # The swap and sort step is done in a complex one-liner.\n                # It swaps l and r, then sorts the suffix. This is suboptimal.\n                nums[l], nums[l+1:], perm_found = nums[r], sorted(nums[l+1:r] + [nums[l]] + nums[r+1:]), True\n                break\n        \n        # If no permutation was found, it's the last one. Sort to get the first.\n        if not perm_found:\n            nums.sort()\n"
  },
  {
    "title": "Longest Valid Parentheses",
    "link": "https://leetcode.com/problems/longest-valid-parentheses",
    "keywords": [
      "#String",
      "#Stack",
      "#DynamicProgramming"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "The stack-based solution involves a single pass through the string of length N. The two-pass solution with counters also traverses the string twice, resulting in O(N)."
      },
      "space": {
        "notation": "O(N)",
        "justification": "The stack can grow up to a size of N in the worst case (e.g., a string of all opening brackets)."
      }
    },
    "whiteboard": "This problem asks for the length of the longest valid (well-formed) parentheses substring. A very clever and robust solution uses a **stack**.\n\nThe stack will store the *indices* of the parentheses. The core idea is that the stack will always have a 'base' index at the bottom, which is the index *just before* the start of a potential valid substring.\n\nAlgorithm:\n1. Initialize a stack and push `-1` onto it. This `-1` acts as the initial base.\n2. Iterate through the string with index `i` and character `c`.\n3. If `c` is an opening bracket `'('`, push its index `i` onto the stack.\n4. If `c` is a closing bracket `')'`, pop from the stack.\n   - If the stack is now empty, it means the current `')'` has no matching `'('`. This `')'` is invalid. We then push its index `i` onto the stack to serve as the new 'base' for the next potential substring.\n   - If the stack is *not* empty after popping, it means we have a valid pair. The length of the current valid substring is `i - stack[-1]` (current index minus the index of the new top of the stack, which is our 'base'). We update our max length with this value.\n\nAfter the loop, the `max_length` variable will hold the answer.",
    "dry_run": "Example: `s = \"(()\"`\n1. `stack = [-1]`, `max_len = 0`.\n2. `i = 0`, `c = '('`. Push `0`. `stack = [-1, 0]`.\n3. `i = 1`, `c = '('`. Push `1`. `stack = [-1, 0, 1]`.\n4. `i = 2`, `c = ')'`. Pop. `stack` is now `[-1, 0]`. It's not empty.\n   - Current length is `i - stack[-1]` => `2 - 0 = 2`.\n   - `max_len` becomes `2`.\n5. Loop ends. Return `max_len`, which is `2`.",
    "test_cases": "- An empty string.\n- String with no valid parentheses (e.g., `))((`)\n- String like `()(()` where the longest is not at the end.\n- A fully valid string `((()))`.",
    "ia_solution": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        # FORYOU!!: The stack-based approach storing indices is a common and powerful pattern for parenthesis problems. Explaining the role of the initial -1 is key to showing deep understanding.\n        stack = [-1] # The stack will store indices, with -1 as a base.\n        max_len = 0\n\n        for i, char in enumerate(s):\n            if char == '(':\n                # Push the index of any opening bracket.\n                stack.append(i)\n            else: # char == ')'\n                # Pop to match the closing bracket.\n                stack.pop()\n                if not stack:\n                    # If stack is empty, this ')' is unmatched.\n                    # Push its index as the new base for future calculations.\n                    stack.append(i)\n                else:\n                    # If stack is not empty, a valid pair was formed.\n                    # The length is the current index minus the index of the element at the top of the stack (the new base).\n                    max_len = max(max_len, i - stack[-1])\n        \n        return max_len\n",
    "manual_solution": "class Solution:\n    def longestValidParentheses(self, s):\n        # FORYOU!!: This is a clever but non-standard two-pass approach. The stack solution (IA solution) is generally what's expected. This solution works by identifying invalid parentheses and then finding the longest gap between them.\n        stack, mx = [], 0\n        \n        # First Pass: Identify the indices of all unmatched parentheses.\n        for i, c in enumerate(s):\n            if c == ')' and stack and s[stack[-1]] == '(': \n                stack.pop()\n            else: \n                stack.append(i)\n        \n        # If the stack is empty after the first pass, the whole string is valid.\n        if not stack: return len(s)\n        \n        # Second Pass: The stack now contains indices of invalid parens.\n        # The longest valid substring is the longest gap between these invalid indices.\n        # We add -1 and len(s) to act as boundaries.\n        stack = [-1] + stack + [len(s)]\n        for i in range(len(stack) - 1):\n            # The length of the valid part is the difference between the indices of two consecutive invalid characters, minus 1.\n            mx = max(mx, stack[i+1] - stack[i] - 1)\n        return mx\n"
  },
  {
    "title": "Search in Rotated Sorted Array",
    "link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
    "keywords": [
      "#Array",
      "#BinarySearch",
      "#Rotated"
    ],
    "complexity": {
      "time": {
        "notation": "O(log N)",
        "justification": "The algorithm is a modified binary search. In each step, we discard half of the search space, which is the hallmark of a logarithmic time complexity."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The search is performed in-place with a few pointers, using constant extra space."
      }
    },
    "whiteboard": "The challenge is to perform a binary search on a sorted array that has been rotated. The standard binary search condition (`target < mid`) is no longer sufficient because the array isn't uniformly sorted. However, the key property is that in any rotated sorted array, *at least one half* (from `left` to `mid`, or `mid` to `right`) must be sorted.\n\nWe can use this property to adapt our binary search:\n1. Initialize `left` and `right` pointers.\n2. In the `while` loop, calculate `mid`.\n3. If `nums[mid]` is the target, we're done.\n4. **Check which half is sorted**: Compare `nums[mid]` with `nums[left]`.\n   - If `nums[left] <= nums[mid]`, the left half is sorted.\n     - We then check if the `target` lies within the range of this sorted left half (`nums[left] <= target < nums[mid]`).\n     - If yes, we search left (`right = mid - 1`).\n     - If no, the target must be in the unsorted right half, so we search right (`left = mid + 1`).\n   - If `nums[left] > nums[mid]`, the right half must be sorted.\n     - We check if the `target` lies within the range of this sorted right half (`nums[mid] < target <= nums[right]`).\n     - If yes, search right (`left = mid + 1`).\n     - If no, search left (`right = mid - 1`).\n5. If the loop finishes, the target was not found.",
    "dry_run": "Example: `nums = [4,5,6,7,0,1,2]`, `target = 0`\n1. `l=0, r=6`. `mid=3`. `nums[mid]=7`. Not target.\n2. Left half `[4,5,6,7]` is sorted (`nums[l] <= nums[mid]`).\n3. Is `target=0` in this range? No. So, search right: `l = mid + 1 = 4`.\n4. `l=4, r=6`. `mid=5`. `nums[mid]=1`. Not target.\n5. Right half `[1,2]` is sorted (`nums[mid] <= nums[r]`).\n6. Is `target=0` in this range? No. So, search left: `r = mid - 1 = 4`.\n7. `l=4, r=4`. `mid=4`. `nums[mid]=0`. Match! Return `mid`, which is `4`.",
    "test_cases": "- Target is the pivot element.\n- Target is in the left sorted portion.\n- Target is in the right sorted portion.\n- The array is not rotated at all.\n- Target is not in the array.",
    "ia_solution": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        # FORYOU!!: This is the standard modified binary search. The key is explaining how you determine which half of the array is sorted in order to correctly narrow down the search space.\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n\n            if nums[mid] == target:\n                return mid\n            \n            # Check if the left half is sorted.\n            if nums[l] <= nums[mid]:\n                # If left half is sorted, check if target is within its range.\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1 # Search left\n                else:\n                    l = mid + 1 # Search right\n            # Otherwise, the right half must be sorted.\n            else:\n                # If right half is sorted, check if target is within its range.\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1 # Search right\n                else:\n                    r = mid - 1 # Search left\n        \n        return -1\n",
    "manual_solution": "class Solution:\n    def search(self, nums, target):\n        # FORYOU!!: This solution is extremely clever and compact, likely from a programming contest. It uses a boolean logic trick with XOR (`^`) or sum to determine which way to move. While it works, it's very difficult to explain in an interview. The standard if/else approach (IA solution) is much clearer and preferred.\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            \n            # This is the core trick. It checks if the target and the middle element\n            # are on the same 'side' of the rotation relative to the start `nums[l]`.\n            # `sum(...) == 2` is a creative way to express a complex boolean condition.\n            # It's essentially checking if exactly two of these three conditions are true.\n            if (target < nums[l]) ^ (nums[mid] < nums[l]) ^ (target < nums[mid]):\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1\n"
  },
  {
    "title": "Find First and Last Position of Element in Sorted Array",
    "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
    "keywords": [
      "#Array",
      "#BinarySearch"
    ],
    "complexity": {
      "time": {
        "notation": "O(log N)",
        "justification": "The solution performs two separate binary searches (one for the left boundary and one for the right boundary), each taking O(log N) time. The total complexity is O(log N) + O(log N) = O(log N)."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The binary searches are performed in-place using a few pointers, resulting in constant extra space."
      }
    },
    "whiteboard": "The problem asks for the starting and ending positions of a target value in a sorted array. A naive linear scan would be O(N). The optimal solution uses a modified **binary search** to achieve O(log N) time.\n\nWe need to perform two binary searches:\n1.  **Find the Leftmost Boundary**: We perform a binary search for the `target`. When we find an instance of the target at `nums[mid] == target`, we don't stop. We know this *could* be the first occurrence, so we record the index and then try to find an even earlier one by continuing our search in the left half (`right = mid - 1`).\n2.  **Find the Rightmost Boundary**: We do a similar binary search. When `nums[mid] == target`, we record the index and try to find a later one by searching in the right half (`left = mid + 1`).\n\nBy combining the results of these two searches, we get the start and end indices. If the target is never found in the initial search, we can immediately return `[-1, -1]`. Python's `bisect` module provides `bisect_left` and `bisect_right` which implement this logic efficiently.",
    "dry_run": "Example: `nums = [5,7,7,8,8,10]`, `target = 8`\n**Find Left Bound:**\n1. `l=0, r=5, mid=2`. `nums[2]=7 < 8`. Search right: `l=3`.\n2. `l=3, r=5, mid=4`. `nums[4]=8`. Match! `left_bound = 4`. Search for earlier: `r = 3`.\n3. `l=3, r=3, mid=3`. `nums[3]=8`. Match! `left_bound = 3`. Search earlier: `r = 2`. Loop ends.\n   - Left bound is `3`.\n**Find Right Bound:**\n1. `l=0, r=5, mid=2`. `nums[2]=7 < 8`. Search right: `l=3`.\n2. `l=3, r=5, mid=4`. `nums[4]=8`. Match! `right_bound = 4`. Search for later: `l = 5`.\n3. `l=5, r=5, mid=5`. `nums[5]=10 > 8`. Search left: `r = 4`. Loop ends.\n   - Right bound is `4`.\nFinal result: `[3, 4]`.",
    "test_cases": "- Target is not in the array.\n- Target is at the beginning or end of the array.\n- The entire array consists of the target value.\n- Array with a single element.",
    "ia_solution": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        # FORYOU!!: An interviewer will want to see you code the binary search yourself. The `bisect` module is great for contests but demonstrates less fundamental knowledge in an interview.\n        left_bound = self.find_bound(nums, target, True)\n        if left_bound == -1:\n            return [-1, -1]\n        right_bound = self.find_bound(nums, target, False)\n        return [left_bound, right_bound]\n\n    def find_bound(self, nums: List[int], target: int, is_left: bool) -> int:\n        l, r = 0, len(nums) - 1\n        bound = -1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                bound = mid # Found a potential bound\n                if is_left:\n                    r = mid - 1 # Try to find an earlier one\n                else:\n                    l = mid + 1 # Try to find a later one\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return bound\n",
    "manual_solution": "import bisect\nclass Solution(object):\n    def searchRange(self, nums, target):\n        # FORYOU!!: Using the `bisect` library is the most Pythonic and concise way to solve this. It's perfectly fine, but be prepared to explain how `bisect_left` and `bisect_right` work internally (i.e., how you would implement them yourself using binary search).\n        \n        # `bisect_left` finds the insertion point for `target`, which is the index of the first occurrence.\n        l = bisect.bisect_left(nums, target)\n        \n        # Check if the target was actually found and is within bounds.\n        if l == len(nums) or nums[l] != target:\n            return [-1, -1]\n        \n        # `bisect_right` finds the insertion point to the right of any existing `target`s.\n        # Subtracting 1 gives the index of the last occurrence.\n        r = bisect.bisect_right(nums, target) - 1\n        \n        return [l, r]\n"
  },
  {
    "title": "Search Insert Position",
    "link": "https://leetcode.com/problems/search-insert-position",
    "keywords": [
      "#Array",
      "#BinarySearch"
    ],
    "complexity": {
      "time": {
        "notation": "O(log N)",
        "justification": "The algorithm uses binary search, which halves the search space in each iteration, leading to logarithmic time complexity."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The search is performed in-place using a few variables for pointers, requiring constant extra space."
      }
    },
    "whiteboard": "This problem is a direct application of **binary search**. We are given a sorted array and a target value. If the target is found, we return its index. If not, we return the index where it *would be* inserted to maintain the sorted order.\n\nThe binary search algorithm works as follows:\n1.  Initialize `left` and `right` pointers to the start and end of the array.\n2.  While `left <= right`:\n    -   Calculate the middle index `mid`.\n    -   If `nums[mid]` equals the `target`, we've found it and can return `mid`.\n    -   If `nums[mid]` is less than the `target`, the target must be in the right half, so we update `left = mid + 1`.\n    -   If `nums[mid]` is greater than the `target`, the target must be in the left half, so we update `right = mid - 1`.\n3.  If the loop finishes without finding the target, the `left` pointer will be at the correct insertion position. This is because the loop terminates when `left` crosses `right`, and `left` will be pointing to the first element that was greater than the target, which is exactly where the target should be inserted.",
    "dry_run": "Example: `nums = [1,3,5,6]`, `target = 2`\n1. `l=0, r=3`.\n2. `mid=1`. `nums[1]=3 > 2`. Search left: `r = mid - 1 = 0`.\n3. `l=0, r=0`. `mid=0`. `nums[0]=1 < 2`. Search right: `l = mid + 1 = 1`.\n4. Loop terminates because `l > r` (`1 > 0`).\n5. Return `l`, which is `1`. The correct insertion index for 2 is indeed 1.",
    "test_cases": "- Target is present in the array.\n- Target should be inserted at the beginning.\n- Target should be inserted at the end.\n- Target should be inserted in the middle.",
    "ia_solution": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        # FORYOU!!: This is a textbook binary search implementation. Be ready to code it from scratch and explain why `left` is the correct return value when the target is not found.\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        # If the loop finishes, `l` is the insertion point.\n        return l\n",
    "manual_solution": "import bisect\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        # FORYOU!!: Using `bisect_left` is the most direct and Pythonic way to solve this problem, as its definition is exactly what the problem asks for. For an interview, however, be prepared to implement the binary search logic manually as shown in the IA solution.\n        # `bisect_left` returns the index where `target` should be inserted to maintain order.\n        # If `target` is already present, it returns the index of the first occurrence.\n        return bisect.bisect_left(nums, target)\n"
  },
  {
    "title": "Valid Sudoku",
    "link": "https://leetcode.com/problems/valid-sudoku",
    "keywords": [
      "#Array",
      "#HashTable",
      "#Set"
    ],
    "complexity": {
      "time": {
        "notation": "O(1)",
        "justification": "The size of the Sudoku board is fixed at 9x9. We iterate through all 81 cells once. Since the input size is constant, the time complexity is O(1)."
      },
      "space": {
        "notation": "O(1)",
        "justification": "We use hash sets to store the seen numbers. The maximum number of elements in these sets is also fixed (at most 9 elements per row/col/box), so the space complexity is constant."
      }
    },
    "whiteboard": "The problem requires us to validate a Sudoku board according to its rules: each row, each column, and each 3x3 sub-grid must contain the digits 1-9 without repetition.\n\nA clean and efficient way to solve this is to use **hash sets** to keep track of the numbers seen so far. We need three collections of hash sets:\n1.  A list or dictionary of 9 sets for the rows.\n2.  A list or dictionary of 9 sets for the columns.\n3.  A dictionary of 9 sets for the 3x3 sub-grids. We can create a unique key for each sub-grid using its row and column index, for example, `(row // 3, col // 3)`.\n\nThe algorithm is a single pass through the board:\n1. Iterate through each cell of the 9x9 board from `(0,0)` to `(8,8)`.\n2. For each cell `(r, c)` containing a number `val` (not a '.'):\n   - Check if `val` is already in the set for row `r`.\n   - Check if `val` is already in the set for column `c`.\n   - Check if `val` is already in the set for the sub-grid `(r // 3, c // 3)`.\n3. If any of these checks are true, we've found a duplicate, and the board is invalid. Return `False`.\n4. If it's a new number for all three contexts, add `val` to the respective sets for the current row, column, and sub-grid.\n5. If the entire loop completes without returning `False`, the board is valid. Return `True`.",
    "dry_run": "Example: Cell `(r=0, c=0)` contains `val='5'`\n1. Check `rows[0]`. Is '5' in it? No. Add it. `rows[0] = {'5'}`.\n2. Check `cols[0]`. Is '5' in it? No. Add it. `cols[0] = {'5'}`.\n3. Check `boxes[(0//3, 0//3)]` which is `boxes[(0,0)]`. Is '5' in it? No. Add it. `boxes[(0,0)] = {'5'}`.\nExample: Later, cell `(r=0, c=4)` contains `val='5'`\n1. Check `rows[0]`. Is '5' in it? Yes, `rows[0]` is `{'5'}`. Return `False`.",
    "test_cases": "- A valid, complete Sudoku board.\n- An invalid board with a duplicate in a row.\n- An invalid board with a duplicate in a column.\n- An invalid board with a duplicate in a 3x3 sub-grid.\n- A partially filled but valid board.",
    "ia_solution": "import collections\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        # FORYOU!!: This single-pass hash set approach is the standard, optimal solution. It's clean, efficient, and easy to explain.\n        rows = collections.defaultdict(set)\n        cols = collections.defaultdict(set)\n        boxes = collections.defaultdict(set) # Key will be (row//3, col//3)\n\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n                if val == '.':\n                    continue\n                \n                box_key = (r // 3, c // 3)\n\n                # Check for duplicates\n                if (val in rows[r] or\n                    val in cols[c] or\n                    val in boxes[box_key]):\n                    return False\n                \n                # Add the value to all three sets\n                rows[r].add(val)\n                cols[c].add(val)\n                boxes[box_key].add(val)\n        \n        return True\n",
    "manual_solution": "import collections\nclass Solution:\n    def isValidSudoku(self, board):\n        # FORYOU!!: This is the correct and optimal solution. The logic is perfect. Using `defaultdict(set)` is a great Pythonic choice.\n        rows, cols, triples = collections.defaultdict(set), collections.defaultdict(set), collections.defaultdict(set)\n        for i, row in enumerate(board):\n            for j, c in enumerate(row):\n                # This is a very compact way to write the check.\n                if c != \".\" and (c in rows[i] or c in cols[j] or c in triples[(i // 3, j // 3)]): \n                    return False\n                # Add the character if it's a number.\n                elif c != \".\": \n                    rows[i].add(c); cols[j].add(c); triples[(i // 3, j // 3)].add(c)\n        return True\n"
  },
  {
    "title": "Sudoku Solver",
    "link": "https://leetcode.com/problems/sudoku-solver",
    "keywords": [
      "#Array",
      "#Backtracking",
      "#Recursion",
      "#DFS"
    ],
    "complexity": {
      "time": {
        "notation": "O(9^m)",
        "justification": "Where m is the number of empty cells. In the worst case, for each of the m empty cells, we might have to try up to 9 different numbers. This leads to an exponential time complexity."
      },
      "space": {
        "notation": "O(m)",
        "justification": "The space complexity is determined by the depth of the recursion stack, which is at most the number of empty cells, m. We also use sets to store existing numbers, but this is O(1) as the board size is fixed."
      }
    },
    "whiteboard": "This problem requires us to solve a Sudoku puzzle, which is a classic application of **backtracking**.\n\nThe overall strategy is:\n1.  **Preprocessing**: First, iterate through the board to identify all empty cells ('.') and to populate our constraint checkers (e.g., hash sets for rows, columns, and 3x3 boxes) with the initial numbers.\n2.  **Backtracking Function**: Create a recursive function, `solve()`, that tries to fill the board one empty cell at a time.\n3.  **Base Case**: The base case for the recursion is when there are no more empty cells to fill. If we reach this state, it means we've successfully found a solution, and we can return `True`.\n4.  **Recursive Step**:\n    -   Pick one empty cell to work on (e.g., the first one in our list of empty cells).\n    -   Try placing each number from '1' to '9' in that cell.\n    -   For each number, check if placing it there is **valid** (i.e., it doesn't violate the row, column, or box constraints).\n    -   If it's a valid move:\n        -   Place the number on the board and update our constraint sets.\n        -   Make a recursive call: `solve()`.\n        -   If the recursive call returns `True`, it means a solution was found down that path, so we also return `True`.\n        -   If it returns `False`, it means this path was a dead end. We must **backtrack**: remove the number from the board, undo the changes to our constraint sets, and try the next number.\n5. If we try all 9 numbers in the cell and none lead to a solution, we return `False` to the previous call.",
    "dry_run": "Example: Empty cell at `(0,0)`.\n1. `solve()` is called. Picks cell `(0,0)`.\n2. Try placing '1' at `(0,0)`. Is it valid? Let's say yes.\n   - Place '1' on board. Update sets.\n   - Call `solve()` for the next empty cell.\n3.   Let's say the next recursive call eventually fails and returns `False`.\n4. Backtrack: Remove '1' from `(0,0)`. Revert sets.\n5. Try placing '2' at `(0,0)`. Is it valid? ...and so on.\nThis process continues, exploring the decision tree until a valid configuration for the entire board is found.",
    "test_cases": "- A standard, solvable Sudoku puzzle.\n- A puzzle that has no solution.\n- A puzzle that is already solved (no empty cells).",
    "ia_solution": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        # FORYOU!!: The key to a clean backtracking solution is managing state. Explain how you keep track of valid moves (e.g., with sets) and how you properly backtrack (undoing a choice) when a path fails.\n        \n        # Pre-populate constraint sets.\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n        empty_cells = []\n\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n                if val != '.':\n                    box_idx = (r // 3) * 3 + (c // 3)\n                    rows[r].add(val)\n                    cols[c].add(val)\n                    boxes[box_idx].add(val)\n                else:\n                    empty_cells.append((r, c))\n\n        def backtrack(cell_idx):\n            # Base case: if we've filled all empty cells, we're done.\n            if cell_idx == len(empty_cells):\n                return True\n\n            r, c = empty_cells[cell_idx]\n            box_idx = (r // 3) * 3 + (c // 3)\n\n            for num_char in \"123456789\":\n                # Check if this number is a valid move.\n                if (num_char not in rows[r] and\n                    num_char not in cols[c] and\n                    num_char not in boxes[box_idx]):\n                    \n                    # Make the move.\n                    board[r][c] = num_char\n                    rows[r].add(num_char)\n                    cols[c].add(num_char)\n                    boxes[box_idx].add(num_char)\n\n                    # Recurse.\n                    if backtrack(cell_idx + 1):\n                        return True\n\n                    # Backtrack if the recursive call failed.\n                    board[r][c] = '.'\n                    rows[r].remove(num_char)\n                    cols[c].remove(num_char)\n                    boxes[box_idx].remove(num_char)\n            \n            return False\n\n        backtrack(0)\n",
    "manual_solution": "import collections\nclass Solution:\n    def solveSudoku(self, board):\n        # FORYOU!!: This is a correct backtracking solution. Using deque for `visit` is a good choice for efficient popleft/appendleft. The IA solution passes an index instead of modifying the list, which can be slightly cleaner.\n        rows, cols, triples, visit = collections.defaultdict(set), collections.defaultdict(set), collections.defaultdict(set), collections.deque([])\n        # Pre-processing step.\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] != \".\":\n                    rows[r].add(board[r][c])\n                    cols[c].add(board[r][c])\n                    triples[(r // 3, c // 3)].add(board[r][c])\n                else:\n                    visit.append((r, c))\n        \n        def dfs():\n            # Base case.\n            if not visit:\n                return True\n            \n            r, c = visit[0]\n            t = (r // 3, c // 3)\n            for dig in {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}:\n                # Check validity.\n                if dig not in rows[r] and dig not in cols[c] and dig not in triples[t]:\n                    # Make move.\n                    board[r][c] = dig\n                    rows[r].add(dig)\n                    cols[c].add(dig)\n                    triples[t].add(dig)\n                    visit.popleft()\n                    # Recurse.\n                    if dfs():\n                        return True\n                    else:\n                        # Backtrack.\n                        board[r][c] = \".\"\n                        rows[r].discard(dig)\n                        cols[c].discard(dig)\n                        triples[t].discard(dig)\n                        visit.appendleft((r, c))\n            return False\n        dfs()\n"
  },
  {
    "title": "Count and Say",
    "link": "https://leetcode.com/problems/count-and-say",
    "keywords": [
      "#String",
      "#Iteration",
      "#Simulation"
    ],
    "complexity": {
      "time": {
        "notation": "O(n * L)",
        "justification": "Where n is the input number and L is the average length of the generated strings. The length of the strings can grow exponentially, but not quite, so this is a loose upper bound. We iterate n-1 times, and each iteration involves scanning the previous string."
      },
      "space": {
        "notation": "O(L_max)",
        "justification": "We need space to store the current and next strings. The space is dominated by the length of the longest string generated."
      }
    },
    "whiteboard": "This problem describes a sequence generation process. `countAndSay(1)` is \"1\". `countAndSay(2)` is the way you would \"say\" \"1\", which is \"one 1\" or \"11\". `countAndSay(3)` is how you say \"11\", which is \"two 1s\" or \"21\", and so on. This is a simulation problem.\n\nThe algorithm is iterative:\n1.  Start with the base case, `result = \"1\"` for `n=1`.\n2.  Loop from `i = 2` to `n`.\n3.  In each iteration, we will generate the next term in the sequence based on the `current` result.\n4.  To do this, we scan the `current` string. We use a pointer and a `count` variable to identify groups of identical consecutive digits.\n5.  For example, to process \"21\", we see a group of one '2', then a group of one '1'.\n6.  As we scan, we build a `next_result` string. When we finish processing a group (either by hitting a new digit or the end of the string), we append the `count` and the digit to `next_result`.\n7.  After scanning the entire `current` string, the `next_result` becomes the new `current` for the next iteration.\n8.  After the loop finishes, `current` holds the nth term.",
    "dry_run": "Example: `n = 4`\n1. `n=1`: `curr = \"1\"`.\n2. **Loop for n=2:**\n   - Scan `curr = \"1\"`. One '1'.\n   - `next_curr` becomes `\"11\"`.\n   - `curr` is now `\"11\"`.\n3. **Loop for n=3:**\n   - Scan `curr = \"11\"`. Two '1's.\n   - `next_curr` becomes `\"21\"`.\n   - `curr` is now `\"21\"`.\n4. **Loop for n=4:**\n   - Scan `curr = \"21\"`. One '2', then one '1'.\n   - `next_curr` becomes `\"12\"` + `\"11\"` = `\"1211\"`.\n   - `curr` is now `\"1211\"`.\n5. Loop ends. Return `\"1211\"`.",
    "test_cases": "- n = 1.\n- n = 4, 5 to check logic.\n- Maximum n value allowed by constraints.",
    "ia_solution": "import itertools\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        # FORYOU!!: Using `itertools.groupby` is a very Pythonic and elegant way to solve this. It cleanly groups consecutive characters. Be prepared to implement it manually as well, using a simple loop and counter, as that demonstrates more fundamental logic.\n        s = \"1\"\n        for _ in range(n - 1):\n            # `groupby` groups consecutive identical elements.\n            # For \"1121\", it yields ('1', <iterator for '1','1'>), ('2', <iterator for '2'>), ('1', <iterator for '1'>).\n            groups = itertools.groupby(s)\n            # Build the next string by taking the length and key of each group.\n            s = \"\".join(f\"{len(list(group))}{key}\" for key, group in groups)\n        return s\n",
    "manual_solution": "class Solution:\n    def countAndSay(self, n):\n        # FORYOU!!: This is a solid manual implementation. It correctly simulates the process. The logic is a bit complex due to handling the end-of-string case inside the loop. The `itertools` solution is more concise.\n        curr = \"1\"\n        # Loop n-1 times to generate the nth term.\n        for i in range(n - 1):\n            tmp, cnt = \"\", 1\n            # Iterate through the current string to build the next one.\n            for j, c in enumerate(curr):\n                if j > 0 and curr[j - 1] == c:\n                    # If same as previous, increment count.\n                    cnt += 1\n                elif j > 0:\n                    # If different from previous, append the previous group's info.\n                    tmp += str(cnt) + curr[j - 1]\n                    # Reset count for the new group.\n                    cnt = 1\n                # This handles the very last group in the string.\n                if j == len(curr) - 1:\n                    tmp += str(cnt) + curr[j]\n            # Update the current string for the next iteration.\n            curr = tmp\n        return curr\n"
  },
  {
    "title": "Combination Sum",
    "link": "https://leetcode.com/problems/combination-sum",
    "keywords": [
      "#Array",
      "#Backtracking",
      "#Recursion",
      "#DFS"
    ],
    "complexity": {
      "time": {
        "notation": "O(N^(T/M + 1))",
        "justification": "Where N is the number of candidates, T is the target, and M is the minimum candidate value. This is a loose upper bound. The number of nodes in the recursion tree can be large and depends on the target and candidate values."
      },
      "space": {
        "notation": "O(T/M)",
        "justification": "The space complexity is determined by the maximum depth of the recursion stack. The deepest the recursion can go is when we use the smallest candidate value repeatedly, which would be `Target / Min_Candidate`."
      }
    },
    "whiteboard": "This problem asks for all unique combinations of numbers from a list that sum up to a target. We can use the same number multiple times. This is a classic **backtracking** problem.\n\nWe define a recursive helper function, `backtrack(remaining_target, current_combination, start_index)`.\n-   `remaining_target`: The value we still need to sum to.\n-   `current_combination`: The list of numbers we've chosen so far.\n-   `start_index`: An index to prevent duplicate combinations. By only choosing candidates from `start_index` onwards, we ensure combinations like `[2,2,3]` are generated but `[2,3,2]` is not, as they are the same combination.\n\nThe logic of the function:\n1.  **Base Case 1 (Success)**: If `remaining_target` is 0, it means we've found a valid combination. We add a copy of `current_combination` to our results list.\n2.  **Base Case 2 (Failure)**: If `remaining_target` is negative, this path is invalid, so we return.\n3.  **Recursive Step**: Iterate through the candidates starting from `start_index`.\n    -   For each candidate `c`, add it to `current_combination`.\n    -   Make a recursive call: `backtrack(remaining_target - c, current_combination, i)`. Crucially, we pass `i` (not `i+1`) as the next start index, because we are allowed to reuse the same element.\n    -   **Backtrack**: After the recursive call returns, we remove `c` from `current_combination` to explore other possibilities.",
    "dry_run": "Example: `c = [2,3,5]`, `t = 8`\n`backtrack(remain, combo, start)`\n1. `backtrack(8, [], 0)`\n2. -> Try `c[0]=2`. Call `backtrack(6, [2], 0)`\n3.   -> Try `c[0]=2`. Call `backtrack(4, [2,2], 0)`\n4.     -> Try `c[0]=2`. Call `backtrack(2, [2,2,2], 0)`\n5.       -> Try `c[0]=2`. Call `backtrack(0, [2,2,2,2], 0)`. Base case. Add `[2,2,2,2]`. Return.\n6.       -> Try `c[1]=3`. Call `backtrack(-1, ...)`. Fail. Return.\n7.     -> Try `c[1]=3`. Call `backtrack(1, [2,2,3], 1)`. Fails. Return.\n8.   -> Try `c[1]=3`. Call `backtrack(3, [2,3], 1)`\n9.     -> Try `c[1]=3`. Call `backtrack(0, [2,3,3], 1)`. Base case. Add `[2,3,3]`. Return.\n... and so on.",
    "test_cases": "- No combination sums to the target.\n- Target is one of the candidates.\n- Candidates list contains duplicates (though the problem states unique candidates).",
    "ia_solution": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        # FORYOU!!: This backtracking/DFS approach is the standard solution. Explaining the role of the `start_index` to prevent duplicate combinations (like [2,3] vs [3,2]) is a key point.\n        res = []\n        \n        def backtrack(remain, combo, start):\n            # Base Case: Success - we've reached the target.\n            if remain == 0:\n                res.append(list(combo))\n                return\n            # Base Case: Failure - we've overshot the target.\n            if remain < 0:\n                return\n            \n            # Recursive Step.\n            for i in range(start, len(candidates)):\n                # Add the candidate to the current combination.\n                combo.append(candidates[i])\n                # Recurse. Pass `i` as the next start index to allow reuse of the same element.\n                backtrack(remain - candidates[i], combo, i)\n                # Backtrack: remove the candidate to explore other paths.\n                combo.pop()\n                \n        backtrack(target, [], 0)\n        return res\n",
    "manual_solution": "class Solution:\n    def combinationSum(self, c, t):\n        # FORYOU!!: This is an iterative implementation of DFS using an explicit stack. It's functionally equivalent to the recursive backtracking solution and is a valid way to solve it. Recursion is often considered more intuitive to write for these problems.\n        res, stack, n = [], [(0, [], 0)], len(c)\n        \n        # The stack stores tuples of (current_sum, current_path, start_index).\n        while stack:\n            sm, tmp, r = stack.pop()\n            \n            # Explore adding next candidates.\n            for i in range(r, n):\n                new_sum = sm + c[i]\n                if new_sum < t:\n                    # If still under target, push the new state onto the stack for further exploration.\n                    stack.append((new_sum, tmp + [c[i]], i))\n                elif new_sum == t:\n                    # If we hit the target, add the combination to the results.\n                    res.append(tmp + [c[i]])\n        return res\n"
  },
  {
    "title": "Combination Sum II",
    "link": "https://leetcode.com/problems/combination-sum-ii",
    "keywords": [
      "#Array",
      "#Backtracking",
      "#Recursion"
    ],
    "complexity": {
      "time": {
        "notation": "O(2^N)",
        "justification": "Where N is the number of candidates. In the worst case, the number of combinations can be exponential. The sorting step takes O(N log N). The backtracking part dominates."
      },
      "space": {
        "notation": "O(N)",
        "justification": "The space is determined by the recursion depth, which can be at most N (if we pick one of each candidate)."
      }
    },
    "whiteboard": "This problem is a variation of Combination Sum. The two key differences are:\n1.  Each number in the `candidates` array may only be used **once** in each combination.\n2.  The `candidates` array itself may contain duplicates. We must ensure our solution set does not contain duplicate combinations.\n\nThe backtracking approach is still the best. The crucial modifications are:\n1.  **Sort the Candidates**: First, sort the `candidates` array. This is essential for easily handling duplicates.\n2.  **Modify Recursion**: In the recursive call `backtrack(..., i)`, we now pass `i + 1` as the next start index: `backtrack(..., i + 1)`. This enforces the rule that each number can be used at most once.\n3.  **Handle Duplicates**: Because the array is sorted, all duplicate numbers are adjacent. To avoid generating duplicate combinations (e.g., using the first '1' and a '7' vs. using the second '1' and a '7'), we add a check inside our loop. If the current element `candidates[i]` is the same as the previous one `candidates[i-1]`, and we are not at the beginning of the loop for this level of recursion (`i > start_index`), we skip it. This ensures that we only generate combinations starting with a duplicate number once.",
    "dry_run": "Example: `c = [10,1,2,7,6,1,5]`, `t = 8`. Sorted `c = [1,1,2,5,6,7,10]`.\n`dfs(remain, combo, start)`\n1. `dfs(8, [], 0)`\n2. -> Try `c[0]=1`. Call `dfs(7, [1], 1)`\n3.   -> Try `c[1]=1`. This is a duplicate. `i > start` is false (1 is not > 1), so we proceed. Call `dfs(6, [1,1], 2)`.\n4.     -> Try `c[2]=2`. Call `dfs(4, [1,1,2], 3)`. Fails.\n5.     -> Try `c[3]=5`. Call `dfs(1, [1,1,6], 4)`. Fails.\n6.     -> Try `c[4]=6`. Call `dfs(0, [1,1,6], 5)`. Base case. Add `[1,1,6]`. Return.\n7.   -> Try `c[2]=2`. Call `dfs(5, [1,2], 3)`.\n8.     -> Try `c[3]=5`. Call `dfs(0, [1,2,5], 4)`. Base case. Add `[1,2,5]`. Return.\n... and so on.",
    "test_cases": "- Candidates with multiple duplicates.\n- No solution exists.\n- A solution uses a duplicate number from the input.",
    "ia_solution": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        # FORYOU!!: The two most important parts to explain here are sorting and the duplicate-skipping logic (`if i > start and ...`).\n        res = []\n        # Sorting is crucial for the duplicate handling logic.\n        candidates.sort()\n\n        def backtrack(remain, combo, start):\n            if remain == 0:\n                res.append(list(combo))\n                return\n            if remain < 0:\n                return\n\n            for i in range(start, len(candidates)):\n                # This is the key to avoiding duplicate combinations.\n                # If the current number is the same as the previous one, and we are not\n                # at the start of the loop for this level, skip it.\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n                \n                combo.append(candidates[i])\n                # Pass i + 1 because each number can only be used once.\n                backtrack(remain - candidates[i], combo, i + 1)\n                combo.pop()\n\n        backtrack(target, [], 0)\n        return res\n",
    "manual_solution": "class Solution: \n    def combinationSum2(self, candidates, target):\n        # FORYOU!!: This solution is very inefficient and likely incorrect for many cases. It creates many copies of the list (`nums[:i] + nums[i+1:]`) and uses `path not in res` which is slow (O(N*len(path))). The sorting and index-based duplicate skipping in the IA solution is the standard, correct approach.\n        res = []\n        # Initial sort is good!\n        self.dfs(sorted(candidates), target, 0, [], res)\n        return res\n\n    def dfs(self, nums, target, index, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            # This check `path not in res` is very slow for a list of lists.\n            res.append(path)\n            return \n        for i in range(len(nums)):\n            # The duplicate check here `if i>0 and nums[i] == nums[i-1]: continue` is often misplaced in this recursive structure and might not work correctly.\n            # The main problem is creating new lists `nums[:i] + nums[i+1:]` in every recursive call, which is very costly.\n            self.dfs(nums[:i] + nums[i+1:], target-nums[i], i, path+[nums[i]], res)\n"
  }
]
