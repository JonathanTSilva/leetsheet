[
  {
    "title": "Two Sum",
    "link": "https://leetcode.com/problems/two-sum/",
    "keywords": [
      "#Array",
      "#HashTable",
      "#Dictionary",
      "#OnePass"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We iterate through the list of N elements exactly once. Each hash table lookup and insertion is an average O(1) operation."
      },
      "space": {
        "notation": "O(N)",
        "justification": "In the worst-case scenario, we might store all N elements in the hash table if no solution is found until the very end of the array."
      }
    },
    "whiteboard": "The optimal approach uses a hash map (dictionary in Python) for a single-pass solution. As we iterate through the array, we store each number and its index. For each element, we calculate its 'complement' (the other number needed to reach the target) and check if that complement already exists in our hash map. This provides an average O(1) lookup time, making it vastly superior to the brute-force method of using two nested loops, which has a time complexity of O(N^2).",
    "dry_run": "Example: `nums = [2, 7, 11, 15]`, `target = 9`\n1. Initialize `nums_hash = {}`.\n2. `i = 0`, `num = 2`. Complement is `7`. Is `7` in hash? No. Add `2` to hash: `{2: 0}`.\n3. `i = 1`, `num = 7`. Complement is `2`. Is `2` in hash? Yes. Return `[hash[2], i]`, which is `[0, 1]`.",
    "test_cases": "- Empty input array.\n- No solution exists in the array.\n- Array with negative numbers.\n- Array with duplicate numbers that form a solution (e.g., `nums=[3,3], target=6`).\n- Target is zero.",
    "raw_solution": "class Solution:\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        nums_hash = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in nums_hash:\n                return [nums_hash[complement], i]\n            nums_hash[num] = i",
    "commented_solution": "class Solution:\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        # The hash map stores numbers we've seen and their indices.\n        nums_hash = {}\n        # FORYOU!!: Interviewer might ask why a hash map (dictionary) is used here.\n        # Answer: It provides O(1) average time complexity for lookups, which is crucial for an overall O(N) solution. A simple array search would be O(N), making the total time O(N^2).\n\n        # Iterate through the list with both index and value.\n        for i, num in enumerate(nums):\n            # Calculate the number needed to reach the target.\n            complement = target - num\n\n            # Check if this required complement is already in our hash map.\n            if complement in nums_hash:\n                # If it is, we've found our pair.\n                return [nums_hash[complement], i]\n\n            # If the complement isn't found, add the current number and its index to the map.\n            # We do this *after* the check to handle cases where a number is used twice (e.g., nums=[3,3], target=6)\n            nums_hash[num] = i"
  },
  {
    "title": "Add Two Numbers",
    "link": "https://leetcode.com/problems/add-two-numbers/",
    "keywords": [
      "#LinkedList",
      "#Math",
      "#Iteration",
      "#Carry",
      "#DummyNode"
    ],
    "complexity": {
      "time": {
        "notation": "O(max(M, N))",
        "justification": "We iterate through the linked lists until both are fully traversed. The number of iterations is determined by the length of the longer list (M or N)."
      },
      "space": {
        "notation": "O(max(M, N))",
        "justification": "The new linked list created to store the result will have a length of at most max(M, N) + 1, where the +1 accounts for a potential final carry."
      }
    },
    "whiteboard": "The problem requires adding two numbers represented by linked lists in reverse order. The most direct approach is to iterate through both lists simultaneously, simulating elementary school addition. We use a `carry` variable to handle sums greater than 9. A `dummy` head node is used to simplify the construction of the result list, avoiding edge cases for the first node.",
    "dry_run": "Example: `l1 = 2->4->3`, `l2 = 5->6->4`\n1. Initialize `carry = 0`, `dummy` node.\n2. Iteration 1: `2 + 5 + 0 = 7`. `carry=0`, `val=7`. Result: `dummy->7`.\n3. Iteration 2: `4 + 6 + 0 = 10`. `carry=1`, `val=0`. Result: `dummy->7->0`.\n4. Iteration 3: `3 + 4 + 1 = 8`. `carry=0`, `val=8`. Result: `dummy->7->0->8`.\n5. Loop ends. Return `dummy.next`.",
    "test_cases": "- One list is longer than the other.\n- Lists of different lengths resulting in a final carry (e.g., `[9,9] + [1]`).\n- One or both lists are empty.\n- Lists containing zeros.",
    "raw_solution": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy = ListNode()\n        cur = dummy\n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n            total = v1 + v2 + carry\n            carry, val = divmod(total, 10)\n            cur.next = ListNode(val)\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummy.next",
    "commented_solution": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        # A dummy node helps simplify the code by providing a fake head.\n        dummy = ListNode()\n        cur = dummy\n\n        # This will hold the carry-over value (0 or 1).\n        carry = 0\n\n        # Loop until we have processed both lists and there's no carry left.\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            total = v1 + v2 + carry\n            carry, val = divmod(total, 10)\n            \n            cur.next = ListNode(val)\n            cur = cur.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
    "keywords": [
      "#String",
      "#SlidingWindow",
      "#HashTable",
      "#Dictionary"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "This is a single-pass sliding window approach. Each character in the string is visited at most twice, once by the right pointer (`i`) and once by the left pointer (`start`)."
      },
      "space": {
        "notation": "O(min(N, M))",
        "justification": "The space is determined by the hash map size, which stores at most M unique characters (where M is the size of the character set) or N characters if all are unique."
      }
    },
    "whiteboard": "This problem is a classic example of the 'Sliding Window' technique. We use two pointers, `start` and `i`, to define a 'window' of a non-repeating substring. A hash map is used to store the most recent index of each character encountered. When a repeating character is found within the current window, we shrink the window by moving the `start` pointer to the position right after the previous occurrence of that character. This ensures O(N) time complexity as each character is visited at most twice.",
    "dry_run": "Example: `s = \"abcabcbb\"`\n1. `start = 0`, `chars = {}`, `mx = 0`.\n2. `i=0, char='a'`. Valid. `mx=1`. `chars={'a':0}`.\n3. `i=1, char='b'`. Valid. `mx=2`. `chars={'a':0, 'b':1}`.\n4. `i=2, char='c'`. Valid. `mx=3`. `chars={'a':0, 'b':1, 'c':2}`.\n5. `i=3, char='a'`. Repeat! `chars['a']` is `0`. `start <= 0` is true. Move `start` to `0+1=1`. Update `chars={'a':3, ...}`.",
    "test_cases": "- Empty string.\n- String with all unique characters.\n- String with all same characters (e.g., 'bbbbb').\n- String with special characters or numbers.",
    "raw_solution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        mx = 0\n        start = 0\n        chars = {}\n        for i, char in enumerate(s):\n            if char in chars and start <= chars[char]:\n                start = chars[char] + 1\n            else:\n                mx = max(mx, i - start + 1)\n            chars[char] = i\n        return mx",
    "commented_solution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # `mx` will store the maximum length found so far.\n        mx = 0\n        # `start` is the starting index of our current non-repeating substring.\n        start = 0\n        # `chars` is a dictionary to store the last seen index of each character.\n        chars = {}\n\n        for i, char in enumerate(s):\n            # Check if we've seen this character before AND if its last occurrence is within our current window.\n            if char in chars and start <= chars[char]:\n                # If so, a repeat has occurred. Move the start of our window.\n                start = chars[char] + 1\n            else:\n                # If no repeat, calculate its length and update the max if needed.\n                mx = max(mx, i - start + 1)\n            \n            # Update the last seen index for the current character.\n            chars[char] = i\n            \n        return mx"
  },
  {
    "title": "Median of Two Sorted Arrays",
    "link": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
    "keywords": [
      "#Array",
      "#BinarySearch",
      "#DivideAndConquer",
      "#Hard"
    ],
    "complexity": {
      "time": {
        "notation": "O(log(min(N, M)))",
        "justification": "This complexity is for the optimal solution which performs a binary search. The search space is the smaller of the two arrays, and it is halved in each step."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The optimal solution operates in-place using a few variables to track partitions, requiring no additional space proportional to the input size."
      }
    },
    "whiteboard": "The optimal solution for this problem has a time complexity of O(log(min(N,M))) and uses binary search. The goal is to find a partition in both arrays such that all elements in the 'left part' are smaller than all elements in the 'right part'. By performing a binary search on the smaller array to find this ideal partition, we can determine the median from the boundary elements (max of the left part and min of the right part) without merging the arrays. This is much more efficient than the naive O(N+M) approach of merging and sorting.",
    "dry_run": "Conceptual Dry Run: Binary search on smaller array `A`. Pick a partition `midA`. Calculate corresponding partition `midB`. Check if `max(leftA) <= min(rightB)` and `max(leftB) <= min(rightA)`. If not, adjust the binary search range in `A` (move left or right) until the condition is met. Once found, calculate median based on the boundary elements and total element count (even/odd).",
    "test_cases": "- One array is empty.\n- Arrays with no overlap in values (e.g., `[1,2]`, `[3,4]`).\n- Arrays with significant overlap.\n- Arrays of greatly different lengths.\n- Arrays with even or odd total number of elements.",
    "raw_solution": "import math\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n        # This is the straightforward, but non-optimal, solution.\n        arr = sorted(nums1 + nums2)\n        n = len(arr)\n        if n % 2 == 0:\n            mid_right = arr[n // 2]\n            mid_left = arr[n // 2 - 1]\n            return (mid_left + mid_right) / 2\n        else:\n            return float(arr[n // 2])",
    "commented_solution": "import math\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n        # This is the straightforward, \"brute-force\" approach.\n        # NOTE: Interviewers expect the O(log(min(N,M))) solution.\n        arr = sorted(nums1 + nums2)\n        n = len(arr)\n        \n        # Acknowledge this solution's inefficiency in an interview.\n\n        if n % 2 == 0:\n            # If even, the median is the average of the two middle elements.\n            mid_right = arr[n // 2]\n            mid_left = arr[n // 2 - 1]\n            return (mid_left + mid_right) / 2\n        else:\n            # If odd, the median is simply the middle element.\n            return float(arr[n // 2])"
  },
  {
    "title": "Longest Palindromic Substring",
    "link": "https://leetcode.com/problems/longest-palindromic-substring/",
    "keywords": [
      "#String",
      "#DynamicProgramming",
      "#ExpandAroundCenter"
    ],
    "complexity": {
      "time": {
        "notation": "O(N^2)",
        "justification": "The 'Expand Around Center' approach has 2N-1 potential centers. For each center, we may expand outwards up to N/2 times in the worst case."
      },
      "space": {
        "notation": "O(1)",
        "justification": "This approach uses a fixed number of variables to store indices, not counting the space for the result string itself, thus requiring constant extra space."
      }
    },
    "whiteboard": "The 'Expand Around Center' technique is an intuitive and efficient way to solve this. It has the same O(N^2) time complexity as the dynamic programming approach but uses O(1) space. The idea is that any palindrome has a center. We iterate through each character of the string, treating it as a potential center, and expand outwards. We must handle two cases for the center: a single character (for odd-length palindromes like 'racecar') and the space between two characters (for even-length palindromes like 'aabbaa').",
    "dry_run": "Example: `s = \"babad\"`\n1. `res = \"\"`.\n2. Loop `i=0`: `check(0,0)` -> 'b'. `res='b'`. `check(0,1)` -> ''.\n3. Loop `i=1`: `check(1,1)` -> 'bab'. `res='bab'`. `check(1,2)` -> ''.\n4. Loop `i=2`: `check(2,2)` -> 'aba'. `len('aba')` is not > `len('bab')`. `res` remains 'bab'.\n5. Continue for all `i`. Final result is 'bab'.",
    "test_cases": "- Empty string.\n- String that is already a palindrome.\n- String with no palindrome longer than 1 character.\n- String with multiple palindromes of the same max length.",
    "raw_solution": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        res = \"\"\n        def check(l, r):\n            while 0 <= l and r < len(s) and s[l] == s[r]:\n                l -= 1\n                r += 1\n            return s[l + 1:r]\n\n        for i in range(len(s)):\n            odd_pal = check(i, i)\n            if len(odd_pal) > len(res):\n                res = odd_pal\n            even_pal = check(i, i + 1)\n            if len(even_pal) > len(res):\n                res = even_pal\n        return res",
    "commented_solution": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        # This will store the longest palindrome found so far.\n        res = \"\"\n\n        # Helper function to perform the expansion.\n        def check(l, r):\n            # Expand as long as pointers are in bounds and characters match.\n            while 0 <= l and r < len(s) and s[l] == s[r]:\n                l -= 1\n                r += 1\n            # Return the valid palindrome found.\n            return s[l + 1:r]\n\n        for i in range(len(s)):\n            # Check for odd length palindromes (center is the character itself).\n            odd_pal = check(i, i)\n            if len(odd_pal) > len(res):\n                res = odd_pal\n\n            # Check for even length palindromes (center is between two characters).\n            even_pal = check(i, i + 1)\n            if len(even_pal) > len(res):\n                res = even_pal\n        \n        return res"
  },
  {
    "title": "ZigZag Conversion",
    "link": "https://leetcode.com/problems/zigzag-conversion/",
    "keywords": [
      "#String",
      "#Array",
      "#Simulation"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We iterate through the input string of length N exactly once to place each character into its respective row."
      },
      "space": {
        "notation": "O(N)",
        "justification": "We create an auxiliary array of strings to store the characters. The total number of characters stored is equal to the length of the input string, N."
      }
    },
    "whiteboard": "This is a direct simulation problem. The most effective method is to create an array of strings, where each string represents a row. We iterate through the input string character by character, appending each one to the correct row. A pointer indicates the current row, and a direction variable (e.g., +1 for down, -1 for up) controls the movement. The direction flips whenever the pointer reaches the top or bottom row.",
    "dry_run": "Example: `s = \"PAYPAL\"`, `numRows = 3`\n1. `res = [\"\", \"\", \"\"]`, `row = 0`, `dir = 1`.\n2. 'P' -> `res[0]`. `row=1`.\n3. 'A' -> `res[1]`. `row=2`.\n4. 'Y' -> `res[2]`. At bottom, `dir=-1`. `row=1`.\n5. 'P' -> `res[1]`. `row=0`.\n6. 'A' -> `res[0]`. At top, `dir=1`. `row=1`.\n7. 'L' -> `res[1]`. Final `res=[\"PA\", \"YAPL\", \"\"]`. Join to `\"PAYAPL\"`.",
    "test_cases": "- `numRows = 1`.\n- `numRows` is greater than or equal to the string length.\n- Empty input string.",
    "raw_solution": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n        res = [\"\"] * numRows\n        row = 0\n        direction = 1\n        for char in s:\n            res[row] += char\n            if row == 0:\n                direction = 1\n            elif row == numRows - 1:\n                direction = -1\n            row += direction\n        return \"\".join(res)",
    "commented_solution": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        # If one row, or enough rows for every char, string doesn't change.\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        # Create a list of empty strings, one for each row.\n        res = [\"\"] * numRows\n        row = 0\n        # Direction controls whether we're moving down (1) or up (-1).\n        direction = 1\n        \n        for char in s:\n            res[row] += char\n            \n            # If we're at the top or bottom, reverse direction.\n            if row == 0:\n                direction = 1\n            elif row == numRows - 1:\n                direction = -1\n            \n            row += direction\n            \n        return \"\".join(res)"
  },
  {
    "title": "Reverse Integer",
    "link": "https://leetcode.com/problems/reverse-integer/",
    "keywords": [
      "#Math",
      "#IntegerOverflow"
    ],
    "complexity": {
      "time": {
        "notation": "O(log10(x))",
        "justification": "The number of iterations is equal to the number of digits in the integer x, which is proportional to log base 10 of x."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The solution uses a fixed number of variables to perform the reversal, regardless of the size of the input integer."
      }
    },
    "whiteboard": "The core of this problem is handling potential 32-bit integer overflow. The best approach is purely mathematical, avoiding string conversion. We can build the reversed integer digit by digit using the modulo (`%`) and division (`//`) operators. In each step, before we multiply our result by 10 and add the new digit, we must check if this operation would push the result beyond `INT_MAX` or `INT_MIN`. This pre-emptive check is the key to a correct solution.",
    "dry_run": "Example: `x = 123`\n1. `rev = 0`.\n2. Loop 1: `digit = 3`, `rev = 3`, `x = 12`.\n3. Loop 2: `digit = 2`, `rev = 32`, `x = 1`.\n4. Loop 3: `digit = 1`, `rev = 321`, `x = 0`.\n5. Loop ends. Return `321`.",
    "test_cases": "- Positive and negative integers.\n- Numbers ending in zero (e.g., `120`).\n- `x = 0`.\n- Numbers that will cause overflow when reversed (e.g., `1534236469`).\n- `INT_MIN` and `INT_MAX` themselves.",
    "raw_solution": "class Solution:\n    def reverse(self, x: int) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n        rev = 0\n        sign = 1 if x >= 0 else -1\n        x = abs(x)\n        while x != 0:\n            digit = x % 10\n            if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and digit > 7):\n                return 0\n            if rev < INT_MIN // 10 or (rev == INT_MIN // 10 and digit < -8):\n                return 0\n            rev = rev * 10 + digit\n            x //= 10\n        return rev * sign",
    "commented_solution": "class Solution:\n    def reverse(self, x: int) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n        rev = 0\n        sign = 1 if x >= 0 else -1\n        x = abs(x)\n\n        while x != 0:\n            digit = x % 10\n            \n            # CRITICAL: Check for potential overflow BEFORE making the change.\n            if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and digit > 7):\n                return 0\n            \n            rev = rev * 10 + digit\n            x //= 10\n            \n        return rev * sign"
  },
  {
    "title": "String to Integer (atoi)",
    "link": "https://leetcode.com/problems/string-to-integer-atoi/",
    "keywords": [
      "#String",
      "#EdgeCases",
      "#FiniteStateMachine"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We perform a single pass over the input string of length N to parse the integer."
      },
      "space": {
        "notation": "O(1)",
        "justification": "We only use a few variables to keep track of the parsing state. The space required does not scale with the input string length."
      }
    },
    "whiteboard": "This problem tests meticulous handling of edge cases. It can be modeled as a finite state machine. The best approach is a manual, state-based parse: 1. Skip leading whitespace. 2. Check for an optional sign ('+' or '-'). 3. Read consecutive digits, building the number. 4. Stop at the first non-digit character. During step 3, it is crucial to check for integer overflow *before* adding the next digit. Finally, clamp the result to the 32-bit signed integer range.",
    "dry_run": "Example: `s = \"   -42\"`\n1. Skip 3 spaces. `i=3`.\n2. Read sign. `s[3]` is '-'. `sign = -1`. `i=4`.\n3. Read digits. `s[4]` is '4'. `res=4`. `i=5`. `s[5]` is '2'. `res=42`. `i=6`.\n4. `s[6]` is end of string. Loop terminates.\n5. Apply sign: `res = -42`. Return -42.",
    "test_cases": "- Leading/trailing whitespace.\n- Presence of '+' or '-' sign.\n- Strings with letters before or after numbers (e.g., 'words and 987').\n- Overflow and underflow cases.\n- Empty string or string with only whitespace.",
    "raw_solution": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n        i, n = 0, len(s)\n        while i < n and s[i] == ' ':\n            i += 1\n        sign = 1\n        if i < n and (s[i] == '+' or s[i] == '-'):\n            if s[i] == '-':\n                sign = -1\n            i += 1\n        res = 0\n        while i < n and s[i].isdigit():\n            digit = int(s[i])\n            if res > INT_MAX // 10 or (res == INT_MAX // 10 and digit > 7):\n                return INT_MAX if sign == 1 else INT_MIN\n            res = res * 10 + digit\n            i += 1\n        return sign * res",
    "commented_solution": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n        i, n = 0, len(s)\n        \n        # 1. Skip leading whitespace\n        while i < n and s[i] == ' ':\n            i += 1\n            \n        # 2. Determine sign\n        sign = 1\n        if i < n and (s[i] == '+' or s[i] == '-'):\n            if s[i] == '-':\n                sign = -1\n            i += 1\n            \n        # 3. Read in digits until a non-digit is found\n        res = 0\n        while i < n and s[i].isdigit():\n            digit = int(s[i])\n            \n            # CRITICAL: Check for overflow before multiplication\n            if res > INT_MAX // 10 or (res == INT_MAX // 10 and digit > 7):\n                return INT_MAX if sign == 1 else INT_MIN\n                \n            res = res * 10 + digit\n            i += 1\n            \n        # 4. Apply sign and return\n        return sign * res"
  },
  {
    "title": "Palindrome Number",
    "link": "https://leetcode.com/problems/palindrome-number/",
    "keywords": [
      "#Math",
      "#NoStringConversion"
    ],
    "complexity": {
      "time": {
        "notation": "O(log10(x))",
        "justification": "The mathematical approach iterates through roughly half the digits of the number x. The total number of digits is log10(x)."
      },
      "space": {
        "notation": "O(1)",
        "justification": "We only use a couple of variables to store the original number and the reversed half, requiring constant extra space."
      }
    },
    "whiteboard": "While converting the number to a string and checking for equality with its reverse is simple, interviewers often ask for a solution without string conversion. The mathematical approach is more efficient in terms of space (O(1)). It involves reversing only the second half of the number and comparing it with the first half. This avoids potential integer overflow issues that can arise from reversing the entire number if it's very large.",
    "dry_run": "Example: `x = 1221`\n1. `x` is positive and doesn't end in 0. OK.\n2. `reverted_half = 0`.\n3. Loop 1: `x=122`, `reverted_half=1`.\n4. Loop 2: `x=12`, `reverted_half=12`.\n5. Loop terminates as `x` is not > `reverted_half`.\n6. Compare `x == reverted_half` (`12 == 12`). It's true. Return `True`.",
    "test_cases": "- Negative numbers (should return False).\n- `0` (should return True).\n- Numbers ending in zero, but not zero itself (e.g., 10, 120 - should return False).\n- Even and odd length palindromes.",
    "raw_solution": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x > 0 and x % 10 == 0):\n            return False\n        reverted_half = 0\n        while x > reverted_half:\n            reverted_half = reverted_half * 10 + x % 10\n            x //= 10\n        return x == reverted_half or x == reverted_half // 10",
    "commented_solution": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        # A negative number cannot be a palindrome.\n        # Also, if a number ends in 0 (and is not 0), it cannot be a palindrome.\n        if x < 0 or (x > 0 and x % 10 == 0):\n            return False\n\n        reverted_half = 0\n        # We only need to revert the second half of the number.\n        while x > reverted_half:\n            reverted_half = reverted_half * 10 + x % 10\n            x //= 10\n\n        # For odd length numbers, the middle digit is irrelevant (e.g., 12321 -> x=12, rev=123).\n        # For even length, x will equal reverted_half.\n        return x == reverted_half or x == reverted_half // 10"
  },
  {
    "title": "Regular Expression Matching",
    "link": "https://leetcode.com/problems/regular-expression-matching/",
    "keywords": [
      "#String",
      "#DynamicProgramming",
      "#Recursion",
      "#Regex",
      "#Hard"
    ],
    "complexity": {
      "time": {
        "notation": "O(S * P)",
        "justification": "The dynamic programming solution fills a 2D table of size S x P, where S and P are the lengths of the string and pattern. Each cell calculation is a constant time operation."
      },
      "space": {
        "notation": "O(S * P)",
        "justification": "We create a DP table of size (S+1) x (P+1) to store the intermediate results of the matching process."
      }
    },
    "whiteboard": "This is a hard problem best solved with Dynamic Programming. A 2D DP table, `dp[i][j]`, can store whether the first `i` characters of the string `s` match the first `j` characters of the pattern `p`. The state transitions depend on the character in the pattern. If it's a normal character or '.', the match depends on the previous characters `dp[i-1][j-1]`. If it's a '*', it introduces two possibilities: the '*' matches zero preceding elements (depending on `dp[i][j-2]`), or it matches one or more (depending on `dp[i-1][j]`).",
    "dry_run": "Conceptual Dry Run: `s=\"aab\", p=\"c*a*b\"`.\n`dp[i][j]` = `s[:i]` matches `p[:j]`.\n`dp[0][0]` = True.\n`dp[0][2]` = True because `c*` can match an empty string.\n`dp[0][4]` = True because `c*a*` can match an empty string.\n`dp[1][4]` (`'a'` vs `'c*a*'`) = True because `a*` matches `'a'`. Depends on `dp[0][4]`.\n... work through the table until `dp[3][5]` is calculated.",
    "test_cases": "- `.` matching any character.\n- `*` matching zero elements.\n- `*` matching multiple elements.\n- Complex patterns like `a.*b`.\n- Empty string or empty pattern.",
    "raw_solution": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] != '*':\n                    if dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.'):\n                        dp[i][j] = True\n                else:\n                    if dp[i][j - 2]:\n                        dp[i][j] = True\n                    elif dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'):\n                        dp[i][j] = True\n        return dp[len(s)][len(p)]",
    "commented_solution": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # DP table initialized to False. dp[i][j] = s[:i] matches p[:j]\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n\n        # Base case: empty string matches empty pattern\n        dp[0][0] = True\n\n        # Handle patterns like \"a*\" that can match an empty string\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        # Fill the rest of the DP table\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] != '*':\n                    if dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.'):\n                        dp[i][j] = True\n                else:\n                    # Option A: '*' means zero occurrences\n                    if dp[i][j - 2]:\n                        dp[i][j] = True\n                    # Option B: '*' means one or more occurrences\n                    elif dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'):\n                        dp[i][j] = True\n\n        return dp[len(s)][len(p)]"
  },
  {
    "title": "Container With Most Water",
    "link": "https://leetcode.com/problems/container-with-most-water",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#Greedy"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We use a single pass with two pointers moving towards each other. Each pointer traverses the array exactly once, resulting in a linear time complexity."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The solution uses a constant amount of extra space for variables like `left`, `right`, and `mx`, regardless of the input array size."
      }
    },
    "whiteboard": "This problem is optimally solved using a two-pointer approach, which is a greedy algorithm. We initialize two pointers, `left` at the beginning and `right` at the end of the array. The width of the container is `right - left`, and the height is limited by the shorter of the two lines (`min(height[left], height[right])`). We calculate this area and keep track of the maximum area found.\n\nThe core insight is how to move the pointers. To potentially find a larger area, we must increase either the width or the height. Since we start at maximum width, the only way to increase the area is by finding a greater height. If we move the pointer of the taller line inwards, the new height will be at best the same as the shorter line, but the width will have decreased, guaranteeing the area cannot be larger. Therefore, we must move the pointer of the shorter line inwards, as this is the only move that holds the potential to find a taller line and thus a larger area. This greedy choice guarantees we never miss the optimal solution. A brute-force approach of checking every pair of lines would be O(N^2), making this two-pointer solution far more efficient.",
    "dry_run": "Example: `height = [1, 8, 6, 2, 5, 4, 8, 3, 7]`\n1. `left = 0`, `right = 8`. `width = 8`. `height = min(h[0], h[8]) = min(1, 7) = 1`. `area = 8 * 1 = 8`. `mx = 8`. `h[left] < h[right]`, so `left++`.\n2. `left = 1`, `right = 8`. `width = 7`. `height = min(h[1], h[8]) = min(8, 7) = 7`. `area = 7 * 7 = 49`. `mx = 49`. `h[left] > h[right]`, so `right--`.\n3. `left = 1`, `right = 7`. `width = 6`. `height = min(h[1], h[7]) = min(8, 3) = 3`. `area = 6 * 3 = 18`. `mx` is still `49`. `h[left] > h[right]`, so `right--`.\n4. ... The process continues until `left >= right`. The final answer is `49`.",
    "test_cases": "- Array where the tallest bars are at the ends.\n- Array where the tallest bars are in the middle.\n- Strictly increasing or decreasing array.\n- Array with only two elements.",
    "raw_solution": "class Solution:\n    def maxArea(self, height):\n        left, right, mx = 0, len(height) - 1, 0\n        while left < right:\n            mx = max(mx, (right - left) * min(height[left], height[right]))\n            if height[left] < height[right]: \n                left += 1\n            else: \n                right -= 1\n        return mx",
    "commented_solution": "class Solution:\n    def maxArea(self, height):\n        # Initialize pointers at both ends of the array and max_area to 0.\n        left, right, mx = 0, len(height) - 1, 0\n\n        # Loop until the pointers meet.\n        while left < right:\n            # Calculate the current area.\n            # Width is the distance between pointers.\n            # Height is limited by the shorter of the two lines.\n            current_area = (right - left) * min(height[left], height[right])\n            mx = max(mx, current_area)\n            \n            # FORYOU!!: Interviewer will ask for the logic behind which pointer to move.\n            # Answer: We move the pointer pointing to the shorter line because it's the limiting factor for the height. Moving the taller pointer would only decrease the width without any chance of increasing the height, thus guaranteeing a smaller area. Moving the shorter pointer gives us a chance to find a taller line, potentially leading to a larger area.\n            if height[left] < height[right]: \n                left += 1\n            else: \n                right -= 1\n        return mx"
  },
  {
    "title": "Integer to Roman",
    "link": "https://leetcode.com/problems/integer-to-roman",
    "keywords": [
      "#String",
      "#Math",
      "#Mapping",
      "#Greedy"
    ],
    "complexity": {
      "time": {
        "notation": "O(1)",
        "justification": "The input integer is bounded (e.g., 1 to 3999). Therefore, the number of operations (divisions, modulo, string concatenations) is constant and does not scale with the magnitude of the input number."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The length of the resulting Roman numeral string is also bounded (e.g., 'MMMCMXCIX' is one of the longest). The space required does not grow with the input number's value."
      }
    },
    "whiteboard": "The most robust and readable way to solve this is with a greedy mapping approach. We create a list of pairs, mapping integer values to their Roman numeral symbols, sorted in descending order. This list must include the subtractive cases (like 900 for 'CM', 400 for 'CD', etc.).\n\nWe iterate through this list. For each value-symbol pair, we check how many times the value can be 'subtracted' from our input number. We append the corresponding symbol that many times to our result string and then update the number using the modulo operator. Because the list is sorted from largest to smallest, we greedily build the Roman numeral correctly.\n\nThe provided solution works by manually handling each place value (thousands, hundreds, tens, ones) with complex conditional logic. While it gets the correct answer, the mapping approach is much cleaner, less error-prone, and easier to explain in an interview.",
    "dry_run": "Example using the standard mapping method: `num = 58`\nMapping: `[(1000, 'M'), (900, 'CM'), ..., (50, 'L'), (40, 'XL'), (10, 'X'), ..., (1, 'I')]`\n1. `num = 58`. Check `1000`, `900`, ... down to `50`. `58 // 50 = 1`. Append 'L'. `num` becomes `8`.\n2. `num = 8`. Check `40`, `10`. `8 // 10 = 0`. ... `8 // 5 = 1`. Append 'V'. `num` becomes `3`.\n3. `num = 3`. Check `4`. `3 // 1 = 3`. Append 'I' three times. `num` becomes `0`.\n4. Loop ends. Final result: 'L' + 'V' + 'III' = 'LVIII'.",
    "test_cases": "- A number with subtractive cases (e.g., 1994 -> MCMXCIV).\n- A number with no subtractive cases (e.g., 3888 -> MMMDCCCLXXXVIII).\n- Edge cases like 4, 9, 40, 90.\n- The maximum number, 3999.",
    "raw_solution": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        # A cleaner, more standard approach is preferred in interviews.\n        val_map = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n            (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n            (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"),\n            (1, \"I\")\n        ]\n        res = \"\"\n        for val, sym in val_map:\n            count = num // val\n            res += sym * count\n            num %= val\n        return res",
    "commented_solution": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        # FORYOU!!: This mapping approach is much cleaner and easier to explain than manual logic for each digit place. It's the standard, expected solution.\n        # The list must be sorted in descending order and include subtractive pairs (900, 400, 90, 4) to handle those cases greedily.\n        val_map = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n            (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n            (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"),\n            (1, \"I\")\n        ]\n        \n        # This will store our final Roman numeral string.\n        res = \"\"\n\n        # Greedily build the string from largest to smallest values.\n        for val, sym in val_map:\n            # See how many times this symbol fits into the remaining number.\n            count = num // val\n            \n            # Append the symbol that many times.\n            res += sym * count\n            \n            # Update the number to the remainder.\n            num %= val\n            \n        return res"
  },
  {
    "title": "Roman to Integer",
    "link": "https://leetcode.com/problems/roman-to-integer",
    "keywords": [
      "#String",
      "#HashTable",
      "#Mapping"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "The solution involves a single pass through the input string of length N. The hash map lookup is an O(1) operation."
      },
      "space": {
        "notation": "O(1)",
        "justification": "A hash map is used to store the values of the Roman numerals, but its size is constant (7 key-value pairs) and does not depend on the input string's length."
      }
    },
    "whiteboard": "The key to this problem is understanding the subtractive rule in Roman numerals, where a smaller value preceding a larger one means subtraction (e.g., 'IV' is 4, not 6). A clever way to handle this is to iterate through the string from right to left.\n\nWe use a hash map to store the integer value of each Roman symbol for quick O(1) lookups. As we iterate from the end, we keep track of the value of the previously seen character. For the current character, if its value is less than the previous one, we subtract it from our total sum (this handles cases like 'I' in 'IV'). Otherwise, we add its value to the sum. This approach correctly accumulates the total by elegantly handling both additive and subtractive cases in a single pass.",
    "dry_run": "Example: `s = \"MCMXCIV\"`\nMap: `{'I':1, 'V':5, 'X':10, 'C':100, 'M':1000}`\nIterate from right to left:\n1. `char = 'V'`. `pre_val = 1` (from 'I'). `val(V) = 5 > 1`. `sum = 5 - 1 = 4`. `pre_val = 5`.\n2. `char = 'C'`. `pre_val = 5`. `val(C) = 100 > 5`. `sum = 4 + 100 = 104`. `pre_val = 100`.\n3. `char = 'X'`. `pre_val = 100`. `val(X) = 10 < 100`. `sum = 104 - 10 = 94`. `pre_val = 10`.\n4. `char = 'M'`. `pre_val = 10`. `val(M) = 1000 > 10`. `sum = 94 + 1000 = 1094`. `pre_val = 1000`.\n5. `char = 'C'`. `pre_val = 1000`. `val(C) = 100 < 1000`. `sum = 1094 - 100 = 994`. `pre_val = 100`.\n6. `char = 'M'`. `pre_val = 100`. `val(M) = 1000 > 100`. `sum = 994 + 1000 = 1994`. `pre_val = 1000`.\nFinal result: `1994`.",
    "test_cases": "- Simple additive case (e.g., 'LVIII').\n- Simple subtractive case (e.g., 'IV').\n- Complex case with multiple subtractions (e.g., 'MCMXCIV').\n- Single character input (e.g., 'X').",
    "raw_solution": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        table = {\"M\": 1000, \"D\": 500, \"C\": 100, \"L\": 50, \"X\": 10, \"V\": 5, \"I\": 1}\n        sm, pre_val = 0, 0\n        for c in s[::-1]:\n            cur_val = table[c]\n            if cur_val < pre_val:\n                sm -= cur_val\n            else:\n                sm += cur_val\n            pre_val = cur_val\n        return sm",
    "commented_solution": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        # Hash map for O(1) value lookups.\n        table = {\"M\": 1000, \"D\": 500, \"C\": 100, \"L\": 50, \"X\": 10, \"V\": 5, \"I\": 1}\n        \n        sm = 0\n        pre_val = 0\n\n        # FORYOU!!: Explain why iterating from right-to-left is a good strategy.\n        # Answer: It simplifies handling the subtractive rule. When we see a character, we only need to compare it with the one immediately to its right (which we've already processed). If the current character is smaller, we know it's a subtraction. This avoids complex lookaheads.\n        for c in s[::-1]: \n            cur_val = table[c]\n            # If the current value is less than the previous (value to its right),\n            # it's a subtractive case like 'IV' (1 before 5) or 'IX' (1 before 10).\n            if cur_val < pre_val:\n                sm -= cur_val\n            else:\n                # Otherwise, it's an additive case.\n                sm += cur_val\n            # Update the previous value for the next iteration.\n            pre_val = cur_val\n            \n        return sm"
  },
  {
    "title": "Longest Common Prefix",
    "link": "https://leetcode.com/problems/longest-common-prefix",
    "keywords": [
      "#String",
      "#Array",
      "#VerticalScanning"
    ],
    "complexity": {
      "time": {
        "notation": "O(S)",
        "justification": "Where S is the total number of characters in all strings. In the worst-case scenario (all strings are identical), we must check every character. This can also be expressed as O(N * M), where N is the number of strings and M is the length of the shortest string."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The algorithm uses a constant amount of extra space. The result is a substring of the first input string, which doesn't count as extra space proportional to the input size."
      }
    },
    "whiteboard": "There are several ways to approach this, but one of the most efficient and straightforward is 'Vertical Scanning'. We imagine the strings arranged in a grid and scan downwards column by column.\n\nWe iterate with an index `j` from `0` to the length of the first string. In each iteration, we check if the character `strs[0][j]` is the same for all other strings at that same index `j`. If we find a mismatch or if any string is shorter than index `j`, we know the common prefix ends at the previous character. We can then return the slice of the first string up to index `j`.\n\nAn alternative is sorting the array of strings first. The longest common prefix of all strings will be the common prefix between the very first and very last strings in the sorted list. This is because sorting groups strings lexicographically, so the most different strings will be at the extremes.",
    "dry_run": "Example: `s = [\"flower\", \"flow\", \"flight\"]`\n1. `j = 0`. Character is 'f'. 'f' is at index 0 in all strings. OK. `j` becomes `1`.\n2. `j = 1`. Character is 'l'. 'l' is at index 1 in all strings. OK. `j` becomes `2`.\n3. `j = 2`. Character is 'o'. 'o' is at index 2 in \"flower\" and \"flow\", but \"flight\" has 'i'. Mismatch.\n4. The loop terminates. The common prefix is the part of the first string up to index `j=2`. Return `s[0][:2]`, which is `\"fl\"`.",
    "test_cases": "- An empty list of strings. Should return \"\".\n- A list with one string. Should return the string itself.\n- All strings are identical.\n- No common prefix exists. Should return \"\".\n- List contains an empty string.",
    "raw_solution": "class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -> str:\n        if not strs:\n            return \"\"\n        \n        for j in range(len(strs[0])):\n            char = strs[0][j]\n            for i in range(1, len(strs)):\n                if j >= len(strs[i]) or strs[i][j] != char:\n                    return strs[0][:j]\n        return strs[0]",
    "commented_solution": "class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -> str:\n        # Handle the edge case of an empty input list.\n        if not strs:\n            return \"\"\n        \n        # FORYOU!!: This is the 'Vertical Scanning' approach. Be ready to explain it.\n        # Answer: We iterate through the characters of the first string (column by column) and for each character, we verify it against all other strings at the same position. This is efficient because it stops at the very first mismatch found.\n\n        # Loop through each character index of the first string.\n        for j in range(len(strs[0])):\n            char_to_match = strs[0][j]\n            \n            # Loop through the rest of the strings to compare.\n            for i in range(1, len(strs)):\n                # The two failure conditions:\n                # 1. The current string `strs[i]` is shorter than the prefix we're checking.\n                # 2. The character at index `j` does not match.\n                if j >= len(strs[i]) or strs[i][j] != char_to_match:\n                    # If we fail, the prefix is the first string up to the current index `j`.\n                    return strs[0][:j]\n\n        # If the outer loop completes, it means the entire first string is a common prefix.\n        return strs[0]"
  },
  {
    "title": "3Sum",
    "link": "https://leetcode.com/problems/3sum",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#Sorting"
    ],
    "complexity": {
      "time": {
        "notation": "O(N^2)",
        "justification": "The initial sort of the array takes O(N log N). The main part of the algorithm is a loop that iterates through N elements, and inside it, a two-pointer approach that takes O(N) time. This results in a dominant time complexity of O(N^2)."
      },
      "space": {
        "notation": "O(N)",
        "justification": "The space complexity depends on the sorting algorithm used. A typical in-place quicksort uses O(log N) stack space, but can be O(N) in the worst case. The space for the result list can also be significant but is usually not counted as extra space. I'll state O(N) to be safe for sorting."
      }
    },
    "whiteboard": "A brute-force solution would check every combination of three numbers, leading to an O(N^3) complexity, which is too slow. The key to an optimized solution is to first sort the input array. Sorting takes O(N log N) but enables a much faster search.\n\nAfter sorting, we iterate through the array with a single pointer `i`. For each `nums[i]`, we need to find two other numbers in the rest of the array (from `i+1` to the end) that sum up to `-nums[i]`. This sub-problem is now the classic 'Two Sum' on a sorted array.\n\nWe solve this sub-problem using two pointers, `l` (left) starting at `i+1` and `r` (right) starting at the end of the array. We calculate the sum `nums[i] + nums[l] + nums[r]`. \n- If the sum is less than zero, we need a larger value, so we increment `l`.\n- If the sum is greater than zero, we need a smaller value, so we decrement `r`.\n- If the sum is zero, we've found a triplet. We add it to our results and move both pointers to search for new pairs.\n\nA crucial step is to handle duplicates. After finding a valid triplet, we must advance our pointers past any subsequent identical elements to ensure each unique triplet is found only once. We also skip duplicates for the initial `i` pointer.",
    "dry_run": "Example: `nums = [-1, 0, 1, 2, -1, -4]`\n1. Sort `nums`: `[-4, -1, -1, 0, 1, 2]`.\n2. `i = 0`, `nums[i] = -4`. `l=1`, `r=5`. Target sum is `4`. `(-1) + 2 = 1 < 4`, so `l++`. `(-1) + 2 = 1 < 4`, `l++`. `0 + 2 = 2 < 4`, `l++`. `1 + 2 = 3 < 4`, `l++`. `l` meets `r`. No solution for `i=0`.\n3. `i = 1`, `nums[i] = -1`. `l=2`, `r=5`. Target sum is `1`. `nums[l]+nums[r] = (-1) + 2 = 1`. Match! Found `[-1, -1, 2]`. Add to results. `l++`, `r--`.\n4. `l=3`, `r=4`. `nums[l]+nums[r] = 0 + 1 = 1`. Match! Found `[-1, 0, 1]`. Add to results. `l++`, `r--`. `l` meets `r`.\n5. `i = 2`, `nums[i] = -1`. This is a duplicate of the previous `i`, so we skip it.\n6. ... and so on. Final result: `[[-1, -1, 2], [-1, 0, 1]]`.",
    "test_cases": "- Array with no solution.\n- Array with many duplicates and zeros.\n- Array where multiple solutions exist for a single `i`.\n- Array is already sorted.",
    "raw_solution": "class Solution:\n    def threeSum(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        nums.sort()\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res",
    "commented_solution": "class Solution:\n    def threeSum(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        # FORYOU!!: The first and most critical step is sorting. Why?\n        # Answer: Sorting allows us to use the two-pointer technique. With a sorted array, we can intelligently move the left and right pointers inwards to find the target sum in O(N) time, which would be impossible in an unsorted array without using extra space (like a hash map).\n        nums.sort()\n\n        # Iterate through the array to pick the first number of the triplet.\n        for i in range(len(nums) - 2):\n            # Skip duplicate values for the first number to avoid duplicate triplets.\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            # Use two pointers for the rest of the array.\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    # Sum is too small, need a larger number, so move left pointer right.\n                    l += 1\n                elif s > 0:\n                    # Sum is too big, need a smaller number, so move right pointer left.\n                    r -= 1\n                else:\n                    # Found a triplet!\n                    res.append([nums[i], nums[l], nums[r]])\n                    # Skip duplicates for the second and third numbers.\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    # Move pointers to find the next unique pair.\n                    l += 1\n                    r -= 1\n        return res"
  },
  {
    "title": "3Sum Closest",
    "link": "https://leetcode.com/problems/3sum-closest",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#Sorting"
    ],
    "complexity": {
      "time": {
        "notation": "O(N^2)",
        "justification": "Similar to 3Sum, the solution is dominated by the nested loop structure (a for loop and a two-pointer while loop) after an initial O(N log N) sort."
      },
      "space": {
        "notation": "O(N)",
        "justification": "Space is required for the sorting algorithm. Typically O(log N) for an in-place sort's recursion stack, but can be O(N) in worst-case scenarios."
      }
    },
    "whiteboard": "This problem is a variation of 3Sum and uses the exact same core algorithm: sorting followed by a two-pointer approach. The key difference is the objective. Instead of finding a sum that exactly equals a target, we want to find a sum that is closest to it.\n\nWe initialize a variable, `closest_sum`, to a very large value. After sorting the array, we iterate through it with a pointer `i`. For each `nums[i]`, we use two pointers, `l` and `r`, to scan the rest of the array. We compute the `current_sum = nums[i] + nums[l] + nums[r]`.\n\nAt each step, we compare the absolute difference `|current_sum - target|` with our smallest difference found so far. If the new difference is smaller, we update our `closest_sum` to be the `current_sum`.\n\nThe logic for moving the pointers remains the same as in Two Sum: if `current_sum` is less than the `target`, we increment `l` to get a larger sum. If it's greater, we decrement `r` to get a smaller sum. If the sum is exactly the target, we have found the absolute closest sum and can return it immediately.",
    "dry_run": "Example: `nums = [-1, 2, 1, -4]`, `target = 1`\n1. Sort `nums`: `[-4, -1, 1, 2]`.\n2. Initialize `diff = infinity`, `res = infinity`.\n3. `i = 0`, `nums[i] = -4`. `l=1`, `r=3`. `sum = -4 + (-1) + 2 = -3`. `| -3 - 1| = 4`. `diff = 4`, `res = -3`. `sum < target`, so `l++`.\n4. `i = 0`, `l=2`, `r=3`. `sum = -4 + 1 + 2 = -1`. `| -1 - 1| = 2`. `diff = 2`, `res = -1`. `sum < target`, so `l++`. `l` meets `r`.\n5. `i = 1`, `nums[i] = -1`. `l=2`, `r=3`. `sum = -1 + 1 + 2 = 2`. `|2 - 1| = 1`. `diff = 1`, `res = 2`. `sum > target`, so `r--`. `l` meets `r`.\n6. Loop finishes. The closest sum found was `2`.",
    "test_cases": "- An exact match for the target exists.\n- All numbers are positive or all are negative.\n- The closest sum is smaller than the target.\n- The closest sum is larger than the target.\n- Array contains duplicates.",
    "raw_solution": "class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -> int:\n        res = diff = float(\"inf\")\n        nums.sort()\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                sm = nums[i] + nums[l] + nums[r]\n                if abs(sm - target) < diff:\n                    diff, res = abs(sm - target), sm\n                if sm < target:\n                    l += 1\n                elif sm > target:\n                    r -= 1\n                else:\n                    return res\n        return res",
    "commented_solution": "class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -> int:\n        # Initialize diff to infinity and the result.\n        diff = float(\"inf\")\n        res = 0 # Will be updated on first iteration.\n\n        # FORYOU!!: Same as 3Sum, sorting is the crucial first step.\n        # Answer: It enables the O(N) two-pointer scan for each element, bringing the total complexity down from O(N^3) to O(N^2).\n        nums.sort()\n\n        for i in range(len(nums) - 2):\n            # Skip duplicates for the first element.\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                sm = nums[i] + nums[l] + nums[r]\n\n                # Check if this sum is closer than the best we've found so far.\n                if abs(sm - target) < diff:\n                    diff = abs(sm - target)\n                    res = sm\n\n                # Move pointers based on comparison with the target.\n                if sm < target:\n                    l += 1\n                elif sm > target:\n                    r -= 1\n                else:\n                    # If sum is exactly the target, this is the closest possible. Return immediately.\n                    return res\n        return res"
  },
  {
    "title": "Letter Combinations of a Phone Number",
    "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number",
    "keywords": [
      "#String",
      "#Backtracking",
      "#Recursion",
      "#Iteration"
    ],
    "complexity": {
      "time": {
        "notation": "O(4^N * N)",
        "justification": "Where N is the length of the input digits string. For each digit, we have up to 4 choices (for '7' and '9'). This branching creates O(4^N) combinations. Each combination has a length of N, and creating it (e.g., via string concatenation) can take O(N) time, leading to the final complexity."
      },
      "space": {
        "notation": "O(4^N * N)",
        "justification": "The space is required to store the output. There are O(4^N) combinations, and each has length N. Additionally, the recursion stack for a backtracking solution would go N levels deep, using O(N) space."
      }
    },
    "whiteboard": "This is a classic backtracking problem. Backtracking is a recursive technique for solving problems by trying to build a solution incrementally, one piece at a time, and removing those solutions that fail to satisfy the constraints of the problem at any point in time.\n\nWe can define a recursive helper function, say `backtrack(index, current_string)`. The `index` tracks which digit we're currently processing, and `current_string` is the combination we've built so far.\nThe base case for the recursion is when `index` equals the length of the input digits. This means we've formed a complete combination, so we add `current_string` to our results list.\nIn the recursive step, we get the letters corresponding to the digit at the current `index`. We then loop through these letters. For each letter, we append it to `current_string` and make a recursive call for the next index: `backtrack(index + 1, current_string + letter)`.\n\nAn iterative solution using a queue (similar to Breadth-First Search) is also possible. You start with an empty string in the queue. For each digit, you dequeue all current combinations, append each possible new letter, and enqueue the new, longer combinations.",
    "dry_run": "Example using backtracking: `digits = \"23\"`\n`backtrack(index, path)`\n1. Call `backtrack(0, \"\")`.\n2. `index=0`, `digit='2'`, letters are `'a', 'b', 'c'`.\n3. Loop 1: Call `backtrack(1, \"a\")`.\n   - `index=1`, `digit='3'`, letters are `'d', 'e', 'f'`.\n   - Loop 1.1: Call `backtrack(2, \"ad\")`. Base case hit (`index=2`). Add \"ad\" to results.\n   - Loop 1.2: Call `backtrack(2, \"ae\")`. Base case hit. Add \"ae\".\n   - Loop 1.3: Call `backtrack(2, \"af\")`. Base case hit. Add \"af\".\n   - Return from `backtrack(1, \"a\")`.\n4. Loop 2: Call `backtrack(1, \"b\")`.\n   - ... adds \"bd\", \"be\", \"bf\".\n5. Loop 3: Call `backtrack(1, \"c\")`.\n   - ... adds \"cd\", \"ce\", \"cf\".\n6. Final result: `[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]`.",
    "test_cases": "- Empty input string. Should return [].\n- Single digit input.\n- Input with digits that map to 3 letters and digits that map to 4 letters.",
    "raw_solution": "class Solution:\n    def letterCombinations(self, digits: str) -> list[str]:\n        if not digits:\n            return []\n        \n        res = []\n        dic = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        \n        def backtrack(index, path):\n            if index == len(digits):\n                res.append(path)\n                return\n            \n            letters = dic[digits[index]]\n            for letter in letters:\n                backtrack(index + 1, path + letter)\n        \n        backtrack(0, \"\")\n        return res",
    "commented_solution": "class Solution:\n    def letterCombinations(self, digits: str) -> list[str]:\n        # Handle the edge case of an empty input string.\n        if not digits:\n            return []\n        \n        res = []\n        dic = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        \n        # FORYOU!!: Be prepared to explain the backtracking approach.\n        # Answer: Backtracking is a recursive algorithm that explores all possible solutions by building a candidate solution step-by-step. When a step leads to a dead end or an invalid solution, it \"backtracks\" to the previous step and tries a different path. Here, each recursive call explores adding one more letter to our combination.\n        def backtrack(index, path):\n            # Base Case: If our path is the same length as the input digits,\n            # we have formed a complete combination.\n            if index == len(digits):\n                res.append(path)\n                return\n            \n            # Recursive Step:\n            # Get the letters for the current digit.\n            letters = dic[digits[index]]\n            # Loop through the letters and make a recursive call for each one.\n            for letter in letters:\n                # The new path is the old path plus the new letter.\n                # The new index moves to the next digit.\n                backtrack(index + 1, path + letter)\n        \n        # Start the backtracking process from the first digit (index 0) with an empty path.\n        backtrack(0, \"\")\n        return res"
  },
  {
    "title": "4Sum",
    "link": "https://leetcode.com/problems/4sum",
    "keywords": [
      "#Array",
      "#TwoPointers",
      "#Sorting",
      "#KSum"
    ],
    "complexity": {
      "time": {
        "notation": "O(N^3)",
        "justification": "After an O(N log N) sort, we have three nested loops. Two explicit `for` loops to fix the first two numbers, and a third implicit loop from the two-pointer scan, which takes O(N) time. This results in a cubic time complexity."
      },
      "space": {
        "notation": "O(N)",
        "justification": "Space is primarily for the sorting algorithm's recursion stack (typically O(log N), worst-case O(N)). The result storage does not count towards auxiliary space complexity."
      }
    },
    "whiteboard": "This problem is a direct extension of 3Sum. The most effective approach is to reduce it to a series of 3Sum (or 2Sum) problems. First, as with all K-Sum problems, we sort the array.\n\nWe use two nested `for` loops to fix the first two numbers of the potential quadruplet, `nums[i]` and `nums[j]`. For each fixed pair, the problem is now reduced to finding two numbers in the rest of the array (`from j+1 to the end`) that sum to a new target: `target - nums[i] - nums[j]`. This is the classic 'Two Sum on a sorted array' problem, which we solve efficiently using the two-pointer technique (`l` and `r`).\n\nDuplicate handling is critical and more complex than in 3Sum. We need to skip duplicates for the `i` pointer, the `j` pointer, and also for the `l` and `r` pointers after a valid quadruplet is found. This ensures that each unique combination is added to the result list only once.",
    "dry_run": "Example: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`\n1. Sort `nums`: `[-2, -1, 0, 0, 1, 2]`\n2. `i = 0`, `nums[i] = -2`.\n   - `j = 1`, `nums[j] = -1`. `new_target = 0 - (-2) - (-1) = 3`. Use two pointers on `[0, 0, 1, 2]`. `l=2, r=5`. `0+2=2 < 3`, `l++`. `0+2=2 < 3`, `l++`. `1+2=3`. Match! Found `[-2, -1, 1, 2]`. Add to results. `l++`, `r--`.\n3. `i = 0`, `nums[i] = -2`.\n   - `j = 2`, `nums[j] = 0`. `new_target = 0 - (-2) - 0 = 2`. Use two pointers on `[0, 1, 2]`. `l=3, r=5`. `0+2=2`. Match! Found `[-2, 0, 0, 2]`. Add to results.\n4. ... The process continues, skipping duplicates, until all combinations are checked. Final result could also include `[-1, 0, 0, 1]`.",
    "test_cases": "- No solution exists.\n- Multiple solutions exist.\n- Array contains many duplicates, positive numbers, negative numbers, and zeros.\n- The target is a large positive or negative number.",
    "raw_solution": "class Solution:\n    def fourSum(self, nums: list[int], target: int) -> list[list[int]]:\n        res = []\n        nums.sort()\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j + 1, len(nums) - 1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s < target:\n                        l += 1\n                    elif s > target:\n                        r -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        while l < r and nums[l] == nums[l+1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r-1]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n        return res",
    "commented_solution": "class Solution:\n    def fourSum(self, nums: list[int], target: int) -> list[list[int]]:\n        res = []\n        # FORYOU!!: Explain how this problem can be generalized to K-Sum.\n        # Answer: You can write a recursive function, `kSum(nums, target, k)`. The base case is when k=2, where you solve it with the standard two-pointer approach. For k > 2, you iterate through the numbers, and for each number `n`, you recursively call `kSum` on the rest of the array with `target-n` and `k-1`. Sorting is required at the beginning, and duplicate handling is needed at each level of recursion.\n        nums.sort()\n\n        # First loop to fix the first number.\n        for i in range(len(nums) - 3):\n            # Skip duplicates for the first number.\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            # Second loop to fix the second number.\n            for j in range(i + 1, len(nums) - 2):\n                # Skip duplicates for the second number.\n                if j > i + 1 and nums[j] == nums[j-1]:\n                    continue\n\n                # Now we have a 2-Sum problem for the rest of the array.\n                l, r = j + 1, len(nums) - 1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s < target:\n                        l += 1\n                    elif s > target:\n                        r -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        # Skip duplicates for the third and fourth numbers.\n                        while l < r and nums[l] == nums[l+1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r-1]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n        return res"
  },
  {
    "title": "Remove Nth Node From End of List",
    "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list",
    "keywords": [
      "#LinkedList",
      "#TwoPointers",
      "#DummyNode"
    ],
    "complexity": {
      "time": {
        "notation": "O(L)",
        "justification": "Where L is the length of the linked list. The algorithm requires a single pass through the list with two pointers."
      },
      "space": {
        "notation": "O(1)",
        "justification": "The optimal two-pointer solution uses a constant amount of extra space (for the two pointers and a dummy node)."
      }
    },
    "whiteboard": "The most elegant solution to this problem uses the two-pointer technique. A naive approach might be to traverse the list once to find its length (L), then traverse it again `L-n` times to find the node to remove. The two-pointer method accomplishes this in a single pass.\n\nFirst, we introduce a `dummy` node that points to the head. This is a crucial trick that simplifies handling edge cases, like removing the actual head of the list.\n\nWe initialize two pointers, `fast` and `slow`, both starting at the `dummy` node. We first advance the `fast` pointer `n+1` steps ahead. The `+1` is so that the `slow` pointer will end up on the node *before* the one we want to delete.\n\nAfter this initial gap is created, we move both `fast` and `slow` pointers one step at a time until `fast` reaches the end of the list (i.e., `fast` is `None`). At this point, `slow` will be positioned exactly before the target node. We can then remove the target node by updating the `next` reference: `slow.next = slow.next.next`.\nFinally, we return `dummy.next`, which is the head of the modified list.",
    "dry_run": "Example: `head = [1,2,3,4,5]`, `n = 2`\n1. Create `dummy` node: `dummy -> 1 -> 2 -> 3 -> 4 -> 5`.\n2. `fast` and `slow` start at `dummy`.\n3. Move `fast` `n+1 = 3` steps ahead. `fast` now points to node `3`. `slow` is still at `dummy`.\n   `slow`\n    \n`dummy -> 1 -> 2 -> 3 -> 4 -> 5`\n                   \n                 `fast`\n4. Now, move `fast` and `slow` together until `fast` reaches the end.\n   - `fast` -> `4`, `slow` -> `1`\n   - `fast` -> `5`, `slow` -> `2`\n   - `fast` -> `None`, `slow` -> `3`. Loop terminates.\n5. `slow` is pointing at node `3`. We need to remove the next node (node `4`).\n6. Execute `slow.next = slow.next.next`. This changes `3.next` from `4` to `5`.\n7. The list is now `dummy -> 1 -> 2 -> 3 -> 5`.\n8. Return `dummy.next`.",
    "test_cases": "- Removing the head of the list (e.g., `n` = length of list).\n- Removing the tail of the list (e.g., `n = 1`).\n- List with only one node, and `n = 1`.\n- A long list.",
    "raw_solution": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        slow = dummy\n        fast = dummy\n        \n        for _ in range(n + 1):\n            fast = fast.next\n            \n        while fast:\n            slow = slow.next\n            fast = fast.next\n            \n        slow.next = slow.next.next\n        return dummy.next",
    "commented_solution": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # FORYOU!!: Always mention using a dummy node and explain why.\n        # Answer: A dummy node simplifies edge cases, particularly when we need to remove the head of the list. Without it, we would need special conditional logic to handle the case where the node to be removed is the first one.\n        dummy = ListNode(0, head)\n        slow = dummy\n        fast = dummy\n        \n        # Advance the fast pointer to create a gap of 'n' nodes between fast and slow.\n        # We move it n+1 steps so that slow will land on the node *before* the target node.\n        for _ in range(n + 1):\n            fast = fast.next\n            \n        # Move both pointers simultaneously until the fast pointer reaches the end of the list.\n        while fast:\n            slow = slow.next\n            fast = fast.next\n            \n        # At this point, 'slow' is the node just before the one we want to remove.\n        # We bypass the target node to effectively delete it.\n        slow.next = slow.next.next\n        \n        # The dummy node's next pointer points to the head of the modified list.\n        return dummy.next"
  },
  {
    "title": "Valid Parentheses",
    "link": "https://leetcode.com/problems/valid-parentheses",
    "keywords": [
      "#String",
      "#Stack",
      "#HashTable"
    ],
    "complexity": {
      "time": {
        "notation": "O(N)",
        "justification": "We iterate through the input string of length N exactly once. Stack push and pop operations are O(1)."
      },
      "space": {
        "notation": "O(N)",
        "justification": "In the worst-case scenario, the input string consists only of opening brackets (e.g., '((({{{'). In this case, the stack would grow to a size of N."
      }
    },
    "whiteboard": "This problem is a perfect use case for a Stack data structure. The Last-In, First-Out (LIFO) nature of a stack mirrors how parentheses must be closed in the reverse order they are opened.\n\nThe algorithm is as follows:\n1. Initialize an empty stack.\n2. Create a hash map to store the matching pairs of brackets (e.g., `')': '('`). This allows for quick lookups.\n3. Iterate through each character of the input string.\n4. If the character is an opening bracket (`(`, `{`, `[`), push it onto the stack.\n5. If the character is a closing bracket (`)`, `}`, `]`), we check two conditions:\n   a. Is the stack empty? If so, we have a closing bracket with no corresponding opener, so the string is invalid.\n   b. Does the top element of the stack match the opening bracket for the current closing bracket? We pop from the stack and check. If they don't match, the string is invalid.\n6. After the loop finishes, if the stack is empty, it means every opening bracket was correctly matched and closed. If the stack is not empty, it means there are unclosed opening brackets.\n\nTherefore, the string is valid if and only if the stack is empty at the very end.",
    "dry_run": "Example: `s = \"([)]\"`\n1. `char = '('`. It's an opener. Push `'('` onto the stack. Stack: `['(']`.\n2. `char = '['`. It's an opener. Push `'['` onto the stack. Stack: `['(', '[']`.\n3. `char = ')'`. It's a closer. Stack is not empty. Pop from stack: `'['`. Does `'['` match the opener for `')'`? No. Return `False`.",
    "test_cases": "- An empty string (should be valid).\n- A valid simple string like `\"()[]{}\"`.\n- A valid nested string like `\"([{}])\"`.\n- An invalid string with wrong order like `\"([)]\"`.\n- An invalid string with unclosed brackets like `\"(((\"`.",
    "raw_solution": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n        for char in s:\n            if char in mapping: # It's a closing bracket\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else: # It's an opening bracket\n                stack.append(char)\n        return not stack",
    "commented_solution": "class Solution:\n    def isValid(self, s: str) -> bool:\n        # The stack will store the opening brackets we encounter.\n        stack = []\n\n        # FORYOU!!: Explain why a stack is the ideal data structure here.\n        # Answer: Parentheses follow a Last-In, First-Out (LIFO) rule. The last bracket that was opened must be the first one to be closed. A stack naturally models this LIFO behavior, making it the perfect tool for matching pairs.\n        \n        # This hash map provides an O(1) lookup for matching brackets.\n        mapping = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n\n        for char in s:\n            # If the character is a closing bracket...\n            if char in mapping:\n                # Pop from the stack if it's not empty, otherwise use a dummy value.\n                top_element = stack.pop() if stack else '#'\n                \n                # Check if the popped element is the corresponding opening bracket.\n                if mapping[char] != top_element:\n                    return False\n            else:\n                # If it's an opening bracket, push it onto the stack.\n                stack.append(char)\n        \n        # After the loop, the string is valid only if the stack is empty.\n        # A non-empty stack means there are unclosed opening brackets.\n        return not stack"
  }
]

